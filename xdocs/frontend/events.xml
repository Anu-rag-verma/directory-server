<?xml version="1.0" encoding="UTF-8"?>
<document>
  <properties>
    <author email="akarasulu@apache.org">Alex Karasulu</author>
    <title>Event Decoupling</title>
  </properties> 
  
  <body>
    <section name="Event Notification Pattern">
      <p>
        The Event Notification Pattern is used to allow components to react to
        events in other components without having to know about the existance 
        of other components.
      </p>
      
      <p>
        The pattern is also known as the dispatcher, decoupler, and publish 
        subscribe pattern.  For more information regarding this pattern look
        at this <a href="http://members.ispwest.com/jeffhartkopf/notifier/">
        article</a>.  Or you can look at the documentation for our event 
        <a href="./components/event/index.html">notification</a> service and 
        its implementation which is an exact manifestation of this pattern as 
        it is described in the artical.
      </p>
    </section>
    
    <section name="Reducing Simple and Cyclic Dependencies">
      <p>
        Using events to drive communication between components reduces 
        dependencies between them.  The frontend subsystem uses a centralized
        event service to implement the event notification pattern to have
        components communicate with one another using events.  The use of 
        the event notification pattern and a common API decouples components
        preventing simple and cyclic dependencies between components and their
        Maven projects.
      </p>
      
      <subsection name="Dependencies Without Events">
        <p>
          Without events, components within the server would interdepend on one
          another through their service interfaces.  For example a dependent 
          component 'FooImpl' may depend on the dependecy, service Bar, which is
          implemented by component 'BarImpl'.  Component FooImpl must be aware 
          of service Bar and is dependent on having at least one component that 
          implements it.  FooImpl must be aware of service interface Bar to call
          methods on it say for example <em>process(Buffer)</em>.  The 
          component diagram below depicts this relationship:
        </p>
        
        <center>
          <img src="../images/dependencies-without-events.gif"/>
        </center>
        
        <p>
          The dependency between the class FooImpl and the Bar service 
          interface makes the the foo-pojo-impl Maven project depend on the 
          bar-spi Maven project.  That's the only way to get FooImpl to see 
          Bar.
        </p>
        
        <table>
          <tr><th>NOTE</th></tr>
          <tr>
            <td>
              <p>
                Every component has an spi and a pojo-impl Maven project and 
                one or more container specific wrapper projects.  For more info
                consult the <a href="../source-layout.html">source organization
                </a> documentation.
              </p>
            </td>
          </tr>
        </table>
        
        <p>
          Here's what the project interdependencies look like for the example
          diagramed above:
        </p>
        
        <table>
          <tr><th>Dependent</th><th>Dependency</th><th>Dangerous?</th></tr>
          <tr>
            <td>foo-pojo-impl</td>
            <td>foo-spi</td>
            <td>Harmless</td>
          </tr>
          <tr>
            <td>foo-pojo-impl</td>
            <td>bar-spi</td>
            <td>Harmful</td>
          </tr>
        </table>
        
        <p>
          We can't avoid dependencies but we need to differentiate between
          ones that are harmful and ones that are not.  And so this brings us 
          to the topic of whether or not a dependency is 'Dangerous?'  Harmful
          dependencies are ones that create interdependencies between
          implementation and service projects.  The only exception to this is 
          when the dependency is to a service that we know is terminal: its 
          implementations now and forever will not depend on other system 
          services or components.
        </p>
      </subsection>
      
      <subsection name="Dependencies With Events">
        <p>
          Instead of having components depend on the service interfaces 
          implemented by other components we use events to decouple them.  
          Continuing the example above, component FooImpl produces and 
          publishes FooEvents using a centralized event publisher service.
          Service Bar's implementation component, BarImpl subscribes for 
          FooEvents.  When BarImpl encounters a FooEvent an event handler 
          invokes the appropriate method <em>process(Buffer)</em> using 
          the Buffer payload packaged with FooEvent.  This way FooImpl need 
          not be aware of service interface Bar and how to invoke the 
          <em>process(Buffer)</em> method on components implementing it.  
          FooImpl just lets everyone subscribed know that it has completed some 
          task that created data in the Buffer by publishing a FooEvent.  
          There is no dependency between FooImpl and service interface Bar 
          anymore as depicted below.
        </p>
        
        <center>
          <img src="../images/dependencies-with-events.gif"/>
        </center>
        
        <p>
          The dependency of the foo-pojo-impl on the bar-spi Maven disolves but
          other ones result.  The bar-spi project now depends on the FooEvent
          class and this class is most likely located within the foo-spi or the
          foo-pojo-impl Maven project jars.  Also both the foo-pojo-impl and 
          other container wrapper implementations for Foo, now additionally 
          depend on the event-spi project.  These dependencies on the 
          event-spi however are marked as harmless because the event service
          and its implementations are terminal: they do not depend on any other
          service or component.  The event service by its nature was designed
          this way since many components would depend on it.  Here's what the 
          project dependencies look like now:
        </p>

        <table>
          <tr><th>Dependent</th><th>Dependency</th><th>Dangerous?</th></tr>
          <tr>
            <td>foo-pojo-impl</td>
            <td>foo-spi</td>
            <td>Harmless</td>
          </tr>
          <tr>
            <td>foo-pojo-impl</td>
            <td>event-spi</td>
            <td>Harmless</td>
          </tr>
          <tr>
            <td>bar-pojo-impl</td>
            <td>bar-spi</td>
            <td>Harmless</td>
          </tr>
          <tr>
            <td>bar-pojo-impl</td>
            <td>foo-spi</td>
            <td>Harmful</td>
          </tr>
          <tr>
            <td>bar-pojo-impl</td>
            <td>event-spi</td>
            <td>Harmless</td>
          </tr>
        </table>
        
        <p>
          Exchanging one harmful dependency for another is not what we wanted.
          The bar-pojo-impl project's dependency on the foo-spi project for
          resolving the FooEvent class is the only harmful dependency left.
          This dependency between projects is due to the fact that the BarImpl 
          subscribes for FooEvents and the FooEvent class is defined in the 
          foo-spi project.  Hence the project dependencey is driven by a class 
          dependency on FooEvent not by a dependency on the Foo service 
          interface.
        </p>
        
        <p>
          To avoid this undesirable situation we maintain events within a 
          common API which does not depend on any other project in the 
          frontend.  Any component may in the future need to subscribe for 
          FooEvents at some point.  Rather than create new dependencies to the
          foo-spi for every new FooEvent subscriber to see the FooEvent class,
          we instead create a dependency to the common API project which has no 
          dependencies in the frontend.  We have intentionally designed 
          subsystem common API packages this way.  By having the bar-pojo-impl 
          depend on the common-api instead of foo-spi we avoid the chance of 
          a cyclic project dependency in the future.  Now the dependencies 
          look like so and all are harmless in this respect:
        </p>
        
        <table>
          <tr><th>Dependent</th><th>Dependency</th><th>Dangerous?</th></tr>
          <tr>
            <td>foo-pojo-impl</td>
            <td>foo-spi</td>
            <td>Harmless</td>
          </tr>
          <tr>
            <td>foo-pojo-impl</td>
            <td>event-spi</td>
            <td>Harmless</td>
          </tr>
          <tr>
            <td>bar-pojo-impl</td>
            <td>bar-spi</td>
            <td>Harmless</td>
          </tr>
          <tr>
            <td>bar-pojo-impl</td>
            <td>common-api</td>
            <td>Harmless</td>
          </tr>
          <tr>
            <td>bar-pojo-impl</td>
            <td>event-spi</td>
            <td>Harmless</td>
          </tr>
        </table>

        <p>
          In the end dependencies are not bad things.  They're necessary.  
          When managing dependencies we must prevent situations where cyclic
          dependencies occur between compilation units, and Maven project's.
          Making sure does not mean cleaning up by refectoring things around 
          after we detect a cycle.  We prevent cycles from ever occuring by 
          only creating harmless dependencies where we can.  Using common apis 
          within subsystems to consolidate shared interfaces and classes is one
          tool.  We always opt to create one or more safer dependencies rather 
          than allow for harmful ones that can later down the road impose 
          cyclic dependencies.
        </p>
      </subsection>
    </section>
  </body>
</document>
