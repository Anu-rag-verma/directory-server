<?xml version="1.0" encoding="UTF-8"?>
<document>
  <properties>
    <author email="akarasulu@apache.org">Alex Karasulu</author>
    <title>Apache Directory Project: Eve Frontend Subsystem</title>
  </properties>
  
  <body>
      <!--
                  At the topmost level, Eve is composed of two major subsystems: the 
          frontend subsystem and the <a href="../backend/index.html">backend</a> 
          subsystem.  
          
            <td>Listener</td>
            <td>
              Manages the set of server socket TCP endpoints used to listen for 
              new connections being established.</td>


        <p>
          The frontend may have components swapped out to make it operate as a
          X.500 directory or as an LDAP frontend to a X.500.  Both the encoding
          and decoding of protocol responses and requests are handled by 
          separate services.  Implementations of these services can encode or 
          decode different kinds of BER messages.  One implementation is 
          designed to work with the LDAP version 3 ASN.1 definition, and another
          can be implemented to work with X.500 ASN.1 definitions.  X.500 now 
          supports the TCP/IP stack in addition to the OSI stack so there is no 
          need to swap out the network components.  All that would be required
          to have the server frontend operate as an X.500 server frontend would
          be the replacement of the set of services dealing with response 
          encodeing and request decodeing.  The processing of these requests
          will also change requiring a new set of request handlers in the heart 
          of the protocol engine which is also designed as a service and 
          implemented as a component.
        </p>
        
        <p>
          Eve's frontend LDAP request processing component is designed today 
          to take each request and operate against a JNDI context using any
          JNDI provider.  Hence the frontend can serve as a virtual directory
          front'ing other LDAP servers or as a LDAP gateway to an X.500 
          directory.
        </p>
        
        <p>
          The frontend is designed using a simplified form of Matt Welsh's 
          <a href="http://www.eecs.harvard.edu/~mdw/proj/seda/">Staged Event 
          Driven Architecture</a> (SEDA).  A short description of SEDA is 
          from Matt Welsh is quoted in the source block below:
        </p>
        
        <source>
SEDA is an acronym for staged event-driven architecture, and decomposes a 
complex, event-driven application into a set of stages connected by queues. 
This design avoids the high overhead associated with thread-based concurrency 
models, and decouples event and thread scheduling from application logic. 
By performing admission control on each event queue, the service can be 
well-conditioned to load, preventing resources from being overcommitted when 
demand exceeds service capacity. SEDA employs dynamic control to automatically 
tune runtime parameters (such as the scheduling parameters of each stage), as 
well as to manage load, for example, by performing adaptive load shedding. 
Decomposing services into a set of stages also enables modularity and code 
reuse, as well as the development of debugging tools for complex event-driven 
applications. 
        </source>
          
        <p>
          The frontend has been designed around the non-blocking channels of 
          the NIO package to handle small chunks of arriving data when that IO 
          is available.  The processing of each chunk is staged in the server 
          and eventually the request built from these peices is itself processed
          in a staged manner.  Our SEDA alignment is very simple without some 
          of the bells and whistles used for the dynamic control of load sheding
          and so on.  We would like to wreak the benefits of high concurrency
          without all the extra features for now at least.
        </p>
        
        <p>
          Eve's frontend subsystem is very flexible.  It's based on a granular 
          set of services and their component implementations.  Everything is 
          plugable and can be reconfigured for different fuctions or swapped out
          for experimentation.  Furthermore the frontend uses JNDI as the 
          coupling interface between it and other systems including the backend
          subsystem so it's very generic.
        </p>
      -->          
          
      <section name="Introduction">
        <p>
          The front end is the network protocol server portion that handles 
          requests by returning zero or more responses.  The following request 
          processing sequence represents an over simplified view of how a 
          request with a single response might be processed within the frontend:
        </p>
        
        <center>
          <img src="../images/req-resp-seq.gif"/>
        </center>
        
        <ol>
          <li>Client sent request is detected and being read</li>
          <li>Decode Basic Encoding Rule (BER) encoded PDU</li>
          <li>Process request by generating a response PDU</li>
          <li>Encode the response PDU for delivery</li>
          <li>Send encoded response PDU out to the client</li>
        </ol>
        
        <p>
          Besides request handling, the frontend manages shared resources and
          aids in the communication between processing stages.  The frontend 
          must also oversee the creation and destruction of client connections 
          and the data associated with a client's session.  In the following 
          sections we explore the requirements leading to the frontend design,
          which meets these functional needs:
        </p>
        
        <table>
          <tr><th>Section</th><th>Description</th></tr>
          
          <tr>
            <td><a href="./requirements.html">Requirements</a></td>
            <td>
              Lists the functional requirements driving the design of the Eve 
              directory server.
            </td>
          </tr>
          
          <tr>
            <td><a href="./x.500-ldap.html">X.500 and LDAP Support</a></td>
            <td>
              Eve's component design makes switching between an X.500 and LDAP
              directory server a matter of reconfiguring the components within 
              the frontend.  The topics pertaining to the support of both 
              protocols using a server core are discussed in detail here.
            </td>
          </tr>
          
          <tr>
            <td><a href="./seda.html">SEDA Approach</a></td>
            <td>
              The simplified implementation of Matt Welsh's Staged Event Driven
              Architecture is documented in this section.
            </td>
          </tr>
          
          <tr>
            <td><a href="./performance.html">High Performance IO</a></td>
            <td>
              Describes in detail the Java NIO API features used to make Eve
              perform fast under heavy load.
            </td>
          </tr>
          
          <tr>
            <td><a href="./events.html">Event Decoupling</a></td>
            <td>
              Discusses the use of an event bus for decoupling components and
              stages within the server leading to less dependencies between
              components and services.
            </td>
          </tr>
          
          <tr>
            <td><a href="./resource-pooling.html">Resource Pooling</a></td>
            <td>
              Eve's frontend pools resources that are expensive to create and 
              destroy.  Pooling of shared resources gets complicated in a 
              staged environment.  Pooled resources the complications of sharing
              them are discussed in this section.
            </td>
          </tr>
          
          <tr>
            <td><a href="./pushing-jndi.html">Pushing the JNDI</a></td>
            <td>
              The frontend is designed to use the JNDI as the interface to an
              entry backing store or other servers altogether.  This unique
              use of the JNDI is explained here.
            </td>
          </tr>
          
          <tr>
            <td><a href="./components/index.html">Components</a></td>
            <td>
              Each component and its service interface is discussed in detail 
              here.
            </td>
          </tr>
          
          <tr>
            <td><a href="./status.html">Current Status</a></td>
            <td>
              Even thought we refer to various peices of functionality within 
              the frontend most of it has yet to be implemented.  Most likely
              the functionality has been stubbed out.  The status describes 
              where we are overall.
            </td>
          </tr>
          
        </table>
      </section>
  </body>
</document>
