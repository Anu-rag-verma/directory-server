<?xml version="1.0" encoding="UTF-8"?>
<document>
  <properties>
    <author email="akarasulu@apache.org">Alex Karasulu</author>
    <title>Apache Directory Project: Software Configuration Management</title>
  </properties>
  
  <body>
    <section name="Overview">
      <p>
        The design for a project has as much to do with how the source code is 
        organized as it does the structure of the program.  This section 
        discusses the software configuration management principals used to 
        organize, maintain and build Eve's code base.
      </p>
      <p>
        After reading this section you should have gained the following:
      </p>
      
      <ul>
        <li>
          Know how the repo is organized and why
        </li>
          
        <li>
          Ability to navigate source and add to it
        </li>
        
        <li>
          Know how to build and deploy Eve
        </li>
      </ul>
    </section>
      
    <section name="Resources">
      <p>
        While reading the next section you might want to use the following 
        resources:
      </p>
        
      <table>
        <tr><th>Resource</th></tr>
        <tr>
          <td><a href="http://cvs.apache.org/viewcvs.cgi/incubator/directory/eve/trunk/eve?root=Apache-SVN">
          Eve's Subversion Repository</a></td>
        </tr>
          
        <tr><td>
          <a href="../../../svn.html">
          Subversion Documentation</a></td>
        </tr>
      </table>
    </section>

    <section name="Organization">
      <subsection name="Repository Layout">
        <p>
          Within the Subversion repository Eve contains several small Maven 
          projects that are consolidated into groups based on subsystem.  Each 
          component within Eve has at least two separate Maven
          projects.  The layout of component and API projects are based on
          Eve's structure.
        </p>
        
        <p>
          A logical distinction is made between various subsystems whose 
          components are separated out in a heirarchy based on function within 
          the source code repository.  The aspects of each subsystem shall be 
          discussed in detail within the documentation set for that subsystem.  
          Developers looking at Eve's source should know that the Subversion 
          repository is structured to mimic this component containment 
          heirarchy.  Here's a brief listing of the directory structure we're 
          referring to:
        </p>
        
        <source>
./eve               -- top component projects and subsystems
  ./frontend        -- contains frontend subsystem APIs and service projects
    ./common        -- contains shared code common to frontend subsystem
      ./api         -- API common to all projects in frontend
    ./buffer        -- frontend buffer service projects
      ./spi         -- frontend buffer service provider interface project
      ./pojo-impl   -- frontend buffer component POJO implementation project
      ./merlin-impl -- frontend buffer component Merlin implementation project
    ./event         -- frontend SEDA event dispatcher service projects
      ./spi         -- frontend event dispatcher SPI project
      ./pojo-impl   -- frontend event dispatcher POJO implementation project
      ./merlin-impl -- frontend event dispatcher Merlin wrapper impl project
      ...
  ./backend
      ...
        </source>
        
        <p>
          The structure above my nest deeper for other subsystems.  For example 
          the backend subsystem has within it other sub subsystems.  Each nested
          subsystem adds an extra level of directory depth.  In turn this 
          subsystem may have other subsystems and/or component directories that 
          have an SPI and an implementation project.
        </p>
      </subsection>
      
      <subsection name="Subsystem Directories and Common APIs">   
        <p>
          Eve is composed of components and these components are logically 
          grouped into subsystems.  For more on Eve's component oriented design
          aspects take a look <a href="./components.html">here</a>.
        </p>
        
        <p>
          Subsystems may contain a common directory used to centralize some 
          classes shared by the subsystem as a common subsystem API of sorts.
          Centralization of common code helps localize domain specific classes 
          and interfaces for a subsystem assigned to a specific function.  Take
          for example the minor schema subsystem which resides under the 
          backend subsystem.  The schema subsystem contains a common API for 
          the various interfaces and classes representing schema objects found 
          within LDAP and X.500.
        </p>
        
        <p>
          The most benefit we gain from these subsystem common APIs is in the
          area of project dependency management.  Natural class dependencies
          will exist within a subsystem.  When dependent classes are distributed
          across several Maven projects within the subsystem interproject 
          dependencies are introduced.  By design dependencies between projects
          will exist to lightly couple the subsystem.  However these class 
          dependencies should not drive the project dependencies between 
          services and components.  If class dependencies are allowed to drive
          project dependencies, you quickly find a web of cyclic project 
          dependencies creating build problems.
        </p>
      </subsection>
      
      <subsection name="Service/Component Directories">
        <p>
          The COP based approach as we said is discussed in more detail 
          within the component design documentation.  However we discuss the
          effects this has on the layout of the subsystem services and the 
          components that implement them within the software repository.
        </p>
        
        <p>
          Components have a service interface and one or more implementations.
          For reasons described within component documentation we separate out 
          the service interface into its own jar along with other helper classes
          and interfaces.  Each implementation is also packaged into its own 
          jar.  Each jar is essentially built by a separate Maven project.  For 
          each service within a subsystem, a top level directory is named after 
          the service like the <em>eve/frontend/buffer</em> directory for the 
          buffer service within the frontend subsystem.  The buffer service 
          creates and pools expensive direct memory buffers for the frontend.  
          The service interface is kept within an <em>'spi'</em> project 
          directory and an implementation is defined within a <em>'pojo-impl'
          </em> directory.  Other implementations of the service may also get 
          their own directory.  For example the Merlin specific wrappers may be 
          packaged under another implementation directory like <em>'merlin-impl'
          </em>.
        </p>
        
        <p>
          The service directory layout pattern is simple and outlined below:
        </p>
        
        <table>
          <tr><th>Directory</th><th>Purpose</th><th>Number</th></tr>
          
          <tr>
            <td>
              *spi
            </td>
            <td>
              contains the SPI jar project
            </td>
            <td>
              In the immortal words of the highlander, "there can only be one!"
            </td>
          </tr>
          
          <tr>
            <td>
              *pojo-impl
            </td>
            <td>
              contains projects for components that implement the service and
              are plain old java objects: they depend on the SPI project
            </td>
            <td>
              one or more: some services have bootstrap and solidstate versions
              and may have more than one implementation
            </td>
          </tr>
          
          <tr>
            <td>
              [container]-*-impl
            </td>
            <td>
              contains projects for components that implement the service and
              are wrappers around the plain old java objects for specific 
              containers: they depend on the SPI project and the POJO
              implementations.  Examples are merlin-impl, loom-impl ...
            </td>
            <td>
              one or more: when we start amassing wrappers for various IoC 
              containers we'll add them here.
            </td>
          </tr>
          
        </table>
      </subsection>
      
      <subsection name="Why go to such lengths?">
        <p>
          One might ask why we have gone to such lengths to separate out our 
          code in this fashion with projects for each service SPI and projects
          for each implementation.
        </p>
        
        <ul>
          <li>
            Source code configuration is just as important as the code, 
            sometimes more so - going the distance is worth it.
          </li>
          
          <li>
            Clean and clear management of project dependencies.
          </li>
          
          <li>
            Project directory names clearly imply the purpose.  SPI is for
            service interfaces.  And the implementations can be differentiated
            with respect to their design (POJO) or the container they're 
            destined to run in.
          </li>
          
          <li>
            Conformance to this pattern down the road will make configuration
            and deployment to various containers easier to maintain and 
            fuctionality to perform these tasks may be shared.
          </li>
          
          <li>
            Container Classloader heirachies can hang multiple implementations
            under an SPI Classloader if the SPI and implementations are kept
            separate.
          </li>
        
          <li>
            A separation of concerns: those interested in a specific container 
            don't care about the wrapper implementation, setup and configuration
            of the wrapper implementations for other containers.
          </li>
          
          <li>
            One pleseant side-effect is that it makes people stop and think 
            about what they are doing in terms of service interfaces and 
            component implementations.
          </li>
          
          <li>
            It makes sense to keep a subsystem's nested subsystems and its 
            services together under one directory.  This way the directory
            heirarchy models the project and service dependencies within the
            system.
          </li>

          <li>
            It makes sense to keep the implementations of a service interface
            together under on umbrella directory for the service.
          </li>
        </ul>
      </subsection>
    </section>
      
    <section name="Building Eve">
      <p>
        Put something here about how we use maven and talk about reactor and
        the organization of projects.  Talk about documentation and site
        content generation.  Talk about the use of a component documentation
        plugin.
      </p>
    </section>
      
    <section name="Deploying Eve">
      <p>
        Talk about deployment tools and issues pertaining to the container.
      </p>
    </section>
      
  </body>
</document>