<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<article lang="en-US">

<sect1><title>Backend Apparatus Redesign</title>
<para/><sect2><title>Goals</title>
<para/>
<para>Several deficiencies in the previous design and the realization of new requirements have brought about the need to redesign the Backend interface and hence the entire backend apparatus of the LDAP server altogether. Our goal is to site these deficiencies and point out the old and new requirements that drive the redesign of the core backend interfaces. In the process we shall discuss the motifs used and review all interface method signatures, their purpose, use, and possible implementations. 
To determine the direction and efficacy of designs, other subsystem design approaches and sometimes their implementation details may be discussed on an as needed basis.</para>
<para/><sect2><title>Background</title>
<para/>
<para>Information presented here describes aspects of the server relavent to the redesign effort. 
Points made are to affect the signatures of core interfaces within the backend apparatus. 
Other points are made to discuss future aspects which can be injected later outside of backend apparatus using interceptors.</para>
<para/><sect3><title>Backends and The Nexus</title>
<para/>
<para>LDAPd has a modular design that enables different Backend implementations to be plugged into the directory to serve entries in different naming contexts. Each naming context has a suffix which represents the root of the naming context. A DSA announces the presence of these naming contexts within the RootDSE using a multivalued namingContext attribute whose values are the suffixes of the naming contexts served. The naming context hence represents a disconnected subtree of the entire DIT served by the DSA.</para>
<para/>
<para>A naming context served by LDAPd corresponds one to one with an atomic backend implementation. By atomic we mean indivisible and so the backend for a context does not contain any other backends. For this reason naming context's cannot be created below or subordinate to other naming contexts. Hence a naming context suffix can not have another suffix as a base in its distinguished name. For example, the naming context dc=example,dc=com would violate this rule if the dc=com naming context existed. LDAPd avoids context subordination in this way to keep search and other algorithms as simple as possible. If partitioning is required under a context then changes in the directory topology with referrals should be used to achieve this end. The one to one relationship between an atomic backend and a naming context leads to our definition of a backend: a backend represents a naming context partition or the subset of the DIB associated with a naming context.</para>
<para/>
<para>LDAPd unifies these disconnected naming contexts under one composite backend or nexus. The nexus itself does not manage entries other than the RootDSE which is addressed by the empty distinguished name (""). Instead of managing the entries under a naming context, the nexus forwards backend operations to the owning backend based on namespace. In essence the nexus is a backend that routes requests. Requests for the RootDSE using the empty DN ("") return the RootDSE and are handled directly by the nexus. Other requests require the resolution of a backend based on namespace. If a backend is resolved for a distinguished name then the call is propagated to the appropriate backend, otherwise the nexus raises a naming exception. The nexus and atomic backends will share operations they have in common and will contain other operations which differentiate their roles. Three interfaces have been devised to model this hierarchical relationship. Backends, the nexus singleton and ancillary supporting modules involved with the aspects of servicing requests against the entire Directory Information Base (DIB) are together referred to as the backend apparatus.</para>
<para/><sect3><title>Role of the Server Side JNDI Provider</title>
<para/>
<para>The server design should easily facilitate integration of the LDAP server with another for an embedded configuration. Furthermore, embedded configurations should have the choice of detaching the frontend from the backend apparatus to prevent protocol driven access if that is desired. These requirements lead to the technical requirement for an integration API.</para>
<para/>
<para>The need for a directory API naturally lead us to the JNDI. A JNDI provider can be written to transduce JNDI calls into nexus calls. The provider effectively wraps the backend apparatus within the JNDI API. LDAPd embedding applications use JNDI to access and modify backends attached to the nexus in the same process space rather than going though the IP stack through the protocol. There were several factors making JNDI the ideal candidate and these factors are listed below:</para>
<itemizedlist>
<title/>
<listitem>
<para>JNDI is an existing open API that developers are already familiar with. The learning curve is practically non-existant.</para>
</listitem>
<listitem>
<para>JNDI has been designed for directories and LDAP from its inception.</para>
</listitem>
<listitem>
<para>Existing LDAP client code can be leveraged without code changes to embed LDAPd. A configuration change specifying the server side provider is all that is required. Client code that worked with a remote LDAPv3 server will work with LDAPd in embedded configurations.</para>
</listitem>
<listitem>
<para>The frontend apparatus can act like a JNDI client to access the backend apparatus resulting in easily understood code and a separable system.</para>
</listitem>
<listitem>
<para>We do not have to reinvent the wheel by creating our own naming and directory operations and classes.</para>
</listitem>
<listitem>
<para>JNDI makes referral handling transparent within the server.</para>
</listitem>
<listitem>
<para>JNDI is a great API for use within stored procedures and trigger bodies to affect changes to backends</para>
</listitem>
</itemizedlist>
<para/>
<para>JNDI is a client API, but the location of the client need not matter. JNDI can be used by clients within the same JVM. The notion of client here is not with respect to location but with respect to the caller. In fact, application servers use server side JNDI providers to manage server environment parameters for J2EE applications. From our perspective the frontend is a JNDI client to the backend apparatus. Applications wishing to embed LDAPd or just its backend apparatus are JNDI clients to the backend apparatus as well.</para>
<para/>
<para>JNDI does come with some impressive benefits however there are drawbacks. JNDI does not have a one to one mapping to from exceptions to LDAP result codes. A JNDI exception can be associated with several result codes. The frontend needs to resolve the exception to a result code in order to correctly respond to clients and this is not possible without a work around. The JNDI exception classes are not final so they can be extended and extra methods can be added to enable result code lookups when the exception's result code is ambiguous. There are a couple of work arounds with the one listed being the cleanest route.</para>
<para/>
<para>Performance inefficiencies could result when the provider transduces datatypes and calls from the JNDI interface to nexus calls. By modeling the new nexus and backend interfaces as close as possible to JNDI interfaces, the cleaner the provider implementation will be. Furthermore, inefficiencies are avoided when the provider has less work to perform while transducing datatypes and calls. This technical requirement to closely model the nexus and backend interfaces as close to JNDI as possible has been one of the major drivers for the redesign.</para>
<para/><sect3><title>Backend Apparatus Aspects</title>
<para/>
<para>Services interven between between calls to the JNDI and the nexus using interceptors. The aspects introduced by these services are listed below:</para>
<itemizedlist>
<title/>
<listitem>
<para>Trigger Activation – aspect where triggers are raised</para>
</listitem>
<listitem>
<para>Authorization – principal target access controls </para>
</listitem>
<listitem>
<para>Replication – replication from the master to replicas</para>
</listitem>
<listitem>
<para>Event Notification – an event notification system enables users to register for notification. This system will make asynchronous JNDI notification possible.</para>
</listitem>
<listitem>
<para>Operational Attribute Management – injecting and updating operational attributes</para>
</listitem>
<listitem>
<para>DN Normalization – normalization of DN attribute values</para>
</listitem>
<listitem>
<para>Schema Checking – determining whether or not changes comply with schema constrainsts</para>
</listitem>
<listitem>
<para>Filter AST Pruning &amp; Augmentation- used to prune undefined attributes, account for attribute inheritence and add extended logic to filter expressions.</para>
</listitem>
<listitem>
<para>Exception handling, tracking and logging.</para>
</listitem>
</itemizedlist>
<para>Although the exact mechanisms specific to each service is not yet determined their introduction will use the interceptor design pattern just outside of the nexus. We need to keep in mind the aspects which can be injected transparently through the interceptor pattern so we do not make the mistake of designing interfaces to implement account for these aspects.</para>
<para/><sect3><title>The System Backend and The System Catalog</title>
<para/>
<para>The Oracle database uses tables within a system tablespace to manage users, groups, schema information and other administrative information within the server. The administrative information stored within this system catalog manages users, tables, and schemas. Effectively, Oracle uses its own machinery to manage itself.</para>
<para/>
<para>It was not long before we realized the need for a formal database to store administrative information. This way we can query the database to rapidly extract the information we want. Why not use a system backend to store a system catalog for LDAPd using entries? Several circumstances warrant the use of a query as opposed to the construction of complex data structures to manage the information used to administer the server.</para>
<para/>
<para>The System Backend is a restricted backend which lacks schema checking or constraints. All attribute data is considered to be a case insensitive string. Filter evaluation is restricted to case insensitive attributes due to a lack of schema information and binary data cannot be indexed due to the effects of normalization. The catalog is expected to hold the following types of administration information using its own specialized DIT structure optimized for various common queries:</para>
<itemizedlist>
<title/>
<listitem>
<para>User Credentials and Profiles</para>
</listitem>
<listitem>
<para>User Permissions</para>
</listitem>
<listitem>
<para>Roles</para>
</listitem>
<listitem>
<para>Role Permissions</para>
</listitem>
<listitem>
<para>Schema Data</para>
</listitem>
<listitem>
<para>Replication Information</para>
</listitem>
<listitem>
<para>Trigger Information</para>
</listitem>
<listitem>
<para>Stored Procedures</para>
</listitem>
</itemizedlist>
<para>These administrative areas of concern and the information used to manage them are maintained here in this backend in the form of searchable entries. The data is kept relational and parameterized which makes it easy to search. The LDAP protocol can be used to manage this area given the right access priveldges. Representations of schema information or access controls information can be constructed on the fly to enable the expected and standard LDAP representation for these structures. For example schema definitions are stored as attributes within the entry referenced by the subscheme subentry attribute. These attribute values for schema definitions follow a standard syntax requiring client side parsing and is very difficult to search. So when asked for the parameterized form would be used to assemble the old school representation. Queries against the system catalog can occur to enable users to ask fine grained questions regarding the schema in effect.</para>
<para/>
<para>The system backend adds another layer of overhead however much of it can be later designed to be in memory with the right caching policy. Still there will be some overhead however the minimal overhead incurred for the sake of better design, organization, and simplicity is well worth it.</para>
<para/><sect2><title>Inteface Design</title>
<para/>
<para>The following overview of the Backend, AtomicBackend and BackendNexus interfaces describes each method of each interface. It discusses each method, its arguments and return types along with the factors controling the signature. The following rules of interface design are generally followed however where appropriate their influences will be specifically stated:</para>
<orderedlist>
<listitem>
<para>Keep the number of interface methods down to the bare minimum avoiding methods of convenience or excessive overloads. As an exception only allow alternative or convenience methods if they impact performance.</para>
</listitem>
<listitem>
<para>The methods must be applicable to all implementations regardless of the backing store and hence the storage mechanism used.</para>
</listitem>
<listitem>
<para>Use the distinguished name of an entry to address it rather than some unique id because the UID may not exist across all implementations, whereas the name does.</para>
</listitem>
<listitem>
<para>Try to stay as close as possible to the DirContext interface operation signatures as possible and borrow as many interfaces and helper classes as possible from JNDI. Why reinvent the wheel?</para>
</listitem>
<listitem>
<para>Presume the automatic operation of various services which do things like normalize distinguished names where needed etcetera. When need be delegate aspects to be implemented as an injected service as provided by an interceptor chain. Interceptor chains will be in effect between the JNDI provider and the nexus.<footnote>
<para>Note that an efficient mechanism to stack aspect services in a chain invoked by a single interceptor on the nexus must be implemented. This will be the most efficient implementation rather than using an interceptor for each service.</para>

</footnote>
 </para>
</listitem>
</orderedlist><sect3><title/><sect3><title>Backend Interface</title>
<para/>
<para>The Backend interface is at the root of the interface heirarchy. It represents the minimum set of operations that must be performed by all backend implementations to enable their efficient operation within the server's backend apparatus. The Backend interface sets the stage for the server backend contract. Let's now review each method within the Backend interface.</para><sect4><title/><sect4><title>Delete Method</title>
<para/>
<para>The delete method is used to remove an entry from the Backend. The entry must be a leaf node or the operation will fail. Deletes on leaf only nodes simplify the implementation of the delete method. Leaf only deletion also complies with <ulink url="http://www.faqs.org/rfcs/rfc2251.html">RFC 2251</ulink>
 which limits delete protocol operations to only leaf nodes.</para>
<para/>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>void delete( Name a_dn ) throws NamingException ; </para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para/>
<para>The method has no return value and takes a single <ulink url="http://java.sun.com/j2se/1.4.2/docs/api/javax/naming/Name.html">Name</ulink>
 argument representing the normalized<footnote>
<para>Normalization a generalized form of text normalization as it is commonly known by, is the process of generating a standard representation for a string based on its schema properties. For example a string which is case insensitive can be transformed into a normalized form by lowercasing it. Normalization is used to generate keys for such strings which will match correctly regardless of case in this example. Most backend interface methods expect Name arguments to be normalized by a service using an interceptor before the call reaches the backend. The normalization occurs using the union of all schema definitions in affect within the server.</para>

</footnote>
 distinguished name of the leaf entry to delete. Attempts to delete an entry that has children, or an entry that does not exist raise a subclass of a <ulink url="http://java.sun.com/j2se/1.4.2/docs/api/javax/naming/NamingException.html">NamingException</ulink>
 . Backend implementors are encouraged to use the subclasses of NamingException supplied within the common packages. These exceptions carry with them unambiguous ResultCodes that can be added to and carried by the exception. Also these exceptions will be massaged by a service that has access to the context used while making this call to the backend. The context information is used to automatically set exception members if they have not already been set as well as log the exception within the backend subsystem.</para><sect3><title/><sect3><title>AtomicBackend Interface</title>
<para>Explain the AtomicBackend methods here and get a link to the javadocs and discuss each method, its arguments, its purpose etcetera.</para>
<para/><sect3><title/><sect3><title>BackendNexus Interface</title>
<para>Explain the BackendNexus methods here and get a link to the javadocs and discuss each method, its arguments, its purpose etcetera.</para>
<para/><sect2><title>Notes On Related Matters</title>
<para/><sect3><title>Exception Handling w/i Backends</title>
<para/>
<para>Exception handling within the backend is very special due to the fact that implementations can throw just about any exception which must then be repackaged as a NamingException to be thrown.</para>
<para/>
<para>NamingExceptions have members to express various aspects of an exception within a naming system. The resolved and unresolved portions of the name are members and are determined when the exception is due to a miss: the named object did not exist. The root exception and the object corresponding to the name (if it was resolved) are members of the NamingException that can be set as well.</para>
<para/>
<para>These members can be set by the nexus or by an interceptor injected service after the exception is thrown. This way backend implementors only need to focus on the resultcode associated with the exception.</para>
<para/><sect3><title>Contexts &amp; Operational Environment Parameters</title>
<para/>
<para>In the course of executing a method, backends may need to access behavior altering parameters stored within the LdapContext that was originally used to make the method call in the first place. These parameters may reflect session specific settings or per request settings. The environment parameters used within the LdapContext alone have several operation modifying affects. These LDAP provider specific properties are documented <ulink url="http://java.sun.com/j2se/1.4.2/docs/guide/jndi/jndi-ldap-gl.html#LDAPPROPS">here</ulink>
 . Other parameters are managed as members of the LdapContext like request and response controls. Methods to these parameters are found in the javadocs for <ulink url="http://java.sun.com/j2se/1.4.2/docs/api/javax/naming/ldap/LdapContext.html">LdapContext</ulink>
 . Access to Controls and environment parameters require access to the LdapContext and hence AtomicBackends will need access to the LdapContext to control the behavior of operations.</para>
<para/>
<para>Right now there is some confusion on how exactly the search method is to be constructed. The confusion comes from a lack of knowing how these parameters are to be communicated to these Backend methods. All these Backend methods can be affected by Controls and environment parameters however search happens to stick out since several aspects of search are altered by both Controls and environment parameters.</para>
<para/>
<para>So the question remains as to how these parameters are made available to AtomicBackends. If they are made available to search they must be made available to all methods. Passing these parameters as method arguments is one way to propagate the data however this butchers interfaces and adds to the stack size. Half the time the context is irrelavent. Also if the context information is used in nested calls all methods in the call chain must pass the context information within as method arguments. There needs to be some generalized mechanism or service available to AtomicBackends for accessing the respective LdapContext that made the call in the first place. </para>
<para/>
<para>The nexus may be a good place to centralize access to the LdapContext associated with a thread of execution. Both AtomicBackends and the JndiProvider will need to have a reference to the nexus. AtomicBackends need the reference to register themselves and the JndiProvider needs the reference to handle JNDI context requests. When a provider implemented LdapContext method is called the provider code transforms the LdapContext method invokation into an equivalent call on the nexus. However before making the call to the nexus, the JndiProvider pushes the context onto a stack associated with the thread of execution using a ThreadLocal. After the call completes and the stack is popped to remove the LdapContext. The JndiProvider can internally manage a stack stored in a ThreadLocal to associate a stack with each thread of execution.</para>
<para/>
<para>The nexus can expose a special one shot interface method to allow the JndiProvider to register a ContextResolver (interface) with it. The method could be a simple setContextResolver method taking a single ContextResolver argument. The ContextResolver can be defined as a JndiProvider inner class with access to the JndiProvider's ThreadLocal object which can be used to return the LdapContext associated with the thread of execution. After the handle is acquired to the nexus within the service() life-cycle method of the JndiProvider, the ContextResolver is instantiated and registered with the nexus using the setContextResolver method on the nexus' service interface. This is a one shot method that cannot be called again without resulting in an exception being thrown.</para>
<para/>
<para>Now the nexus' service interface exposes a getLdapContext method which returns the LdapContext associated with the current thread of execution or null if one is not associated. This configuration using the JndiProvider and the nexus allows the provider to manage the context stack which belongs to it. If the nexus owned the context stack it would have to expose service interface methods to push and pop LdapContexts from it. This would allow backends and other blocks within the server with access to the nexus to interfere with the process of managing the context stacks of threads. This is not an exceptible circumstance both in terms of ecapsulation and security. By using the one shot setContextResolver method on the nexus and the ContextResolver inner class instance within the JndiProvider, we hide the mechanism and encapsulate it where it belongs. The only method exposed and related to this process on the nexus is the getLdapContext method which only returns a non-null value when called from within an AtomicBackend. It is never called by the JndiProvider since the provider already has access to the ThreadLocal. If called by blocks other than the provider and backends it returns null. This is because the call did not take place through the JNDI – context stack management only occurs when calls against the backends occur through the JNDI.</para>
<para/>
<para>Let's go through the sequence of events at startup to initialize the system. The kernel first brings up the nexus, then the backends and the JndiProvider. The order is due to the provider's and backends' dependency on the nexus. Once the JndiProvider has gone through the initialization stage it's ThreadLocal has been created and the provider is ready to begin managing context stacks. Once the nexus is available the JndiProvider gets a handle on the nexus within the service method. The provider then instantiates a ContextResolver defined as an inner class and calls the setContextResolver method of the nexus for the first time.</para>
<para/>
<para>In the solid state, calls on LdapContexts are translated to calls against the nexus. Before the translated call against the nexus is made the provider accesses the stack associated with the current thread of execution using a ThreadLocal member. The LdapContext making the nexus call is then pushed by the provider onto this stack then the call to the nexus is made. From this point on until the stack is popped or pushed calls made by this thread within any backends to the getLdapContext method of the nexus will return the pushed context that initiated the backend call. Once the nexus completes the operation, the provider pops the stack to remove the LdapContext the call was made on.</para>
<para/>
<para>There are some special stituations that require some attention using this model. Some operations against the nexus may raise triggers which execute body that may call stored procedures. Within a stored procedure or a trigger body the JNDI can be used to operate against a backend. Under these situations another LdapContext may be pushed onto the stack before the first LdapContext is popped. In this situation, JNDI calls made via the trigger would complete and pop the topmost LdapContext off of the stack. Then finally the LdapContext of the operation that raised the trigger would be popped off of the stack once the original operation completes. One trigger can raise another in a cascade effect. Such circumstances simply keep pushing and popping LdapContexts.</para>
<para/><sect3><title>Trigger Cascade &amp; Recursion</title>
<para/>
<para>It is beyond the scope of this document to define how triggers are implemented. However we need to make sure that decisions made here allow for a trigger mechanism. All trigger types will be synchronous and shall be raised using an interceptor that introspects on the operation at hand before and after and instead of execution. There are four major problems triggers have to over come to function properly. First triggers need to be able to fire and allow for other triggers to be raised in a cascade. As we saw earlier the context stack elegantly handles the problem of keeping track of contexts with trigger firings. The stack structure allows for the cascade to occur. Second, the trigger mechanism must have a standard means to pass operation parameters to a trigger body for manipulation. The context stack tracking operations an their settings again comes to the rescue. The interceptor has all the parameters of the call as well as the context of the operation at its disposal for presenting the operation parameters to triggers. Third, the system must determine if the owner of the raising operation has execute rights to the trigger. Again this can be determined using the identity of the topmost context on the stack and the owner of the trigger. Fourth perhaps hardest of all the system must be able to detect and stop direct and chain recursion within the cascade. To prevent it we need to be able to define what the recursion really means. Recursion here is not the fact that the same trigger causes itself some time later to fire. The same trigger must cause itself some time later to fire with the same "operational context". This would be a valid form of recursion. If some number of recurences are detected one after the other or in a chain, then the system must halt execution even though time constraints will probably time out the operation anyway. This can be done by collecting the operational context information and the trigger firing information and keeping track of it as the cascade occurs. A list can be used to track these "trigger firing contexts". Every new trigger raised can have its trigger firing context added to the list and inspected to see if it is part of a recurence. Again having the executing thread's context stack and the parameters of calls available within an interceptor helps us build a trigger firing context list to detect cascade cycles which lead to infinite recursion. The current mechanism facilitates the tracking of trigger firing contexts within a trigger subsystem without presenting any red lights.</para>
<para/></sect3></sect3></sect3></sect2></sect3></sect3></sect3></sect3></sect4></sect4></sect3></sect3></sect2></sect3></sect3></sect3></sect3></sect2></sect2></sect1>
</article>
