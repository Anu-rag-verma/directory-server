<?xml version="1.0" encoding="UTF-8"?>
<body>
	<p>
		Just some unorganized list of notes for now.  Later on I'll turn
		them into a real package.html.
	</p>
	
	<ul>
		<li>
		Keep in mind that we have alternative after pipelines.  One for
		success and one for failure.  So because of this we can fail
		fast within the before pipeline.  We do not need to put cleanup 
		interceptors in this before pipeline or the after pipeline.  The
		failure pipeline will contain these cleanup interceptors.  So 
		there is no need to force other Interceptors downstream from a
		failed interceptor to continue processing the Invocation.
		</li>
		
		<li>
		The before pipeline interceptor does not need to supress the 
		exceptions thrown by its constituant interceptors.  The invoke 
		method on the before pipeline be fail fast and should pass through 
		all InterceptorExceptions allowing them to funnel up.  It should 
		catch other unexpected exceptions or errors and wrap them in 
		InterceptorExceptions and rethrow them funneling them up as well.
		</li>
		
		<li>
		This means its probably best to let Interceptors throw 
		InterceptorExceptions as part of the invoke signature rather than
		using a throws on all Throwables.
		</li>
		
		<li>
		Do we have to stuff the Invocation with the InterceptorException
		generated?  This may be required.  Yes the exception will be caught
		by the InvocationHandler to allow the afterFailure pipeline to 
		execute and note that the afterFailure pipeline might need to know
		at which Interceptor and why the Invocation failed.  That's why
		we need to add these InterceptorExceptions to the Invocation.  Its
		part of the entire report.
		</li>

		<li>
		Does the after pipeline need to be fail fast?  It might be best to 
		keep the after pipeline fail fast because this is a critical pathway.  
		Any failure should halt the process and report the error.  At the top 
		level the InvocationHandler will catch these errors and automatically 
		invoke the afterFailure pipeline.  According to this system the call 
		has not completed successfully until every interceptor within the after 
		pipeline has executed successfully.  It might be a good idea to have 
		some Invocation state enumeration type to denote the various states 
		the Invocation is under.
		</li>

		<li>
		Does the afterFailure pipeline need to be fail fast?  Here we need
		to avoid being fail fast and make sure that every cleanup Interceptor
		is executed regardless of upstream errors.  This is because the after
		Failure pathway is for exceptional situations and not for normal 
		processing.  Errors here must be caught as well.
		</li>
		
		<li>
		The addInterceptorThrowable() should be broken apart into three 
		categories of Exceptions tracked with the setThrowable being perhaps
		a fourth category.  The first category would be the before interceptor
		exceptions, the second the after interceptor exceptions, and the last
		being the afterFailure interceptor exceptions.
		</li>
	</ul>
	
	
</body>