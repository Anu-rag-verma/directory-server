/*
 *                                 Apache License
 *                           Version 2.0, January 2004
 *                        http://www.apache.org/licenses/
 *
 *   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 *   1. Definitions.
 *
 *      "License" shall mean the terms and conditions for use, reproduction,
 *      and distribution as defined by Sections 1 through 9 of this document.
 *
 *      "Licensor" shall mean the copyright owner or entity authorized by
 *      the copyright owner that is granting the License.
 *
 *      "Legal Entity" shall mean the union of the acting entity and all
 *      other entities that control, are controlled by, or are under common
 *      control with that entity. For the purposes of this definition,
 *      "control" means (i) the power, direct or indirect, to cause the
 *      direction or management of such entity, whether by contract or
 *      otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *      outstanding shares, or (iii) beneficial ownership of such entity.
 *
 *      "You" (or "Your") shall mean an individual or Legal Entity
 *      exercising permissions granted by this License.
 *
 *      "Source" form shall mean the preferred form for making modifications,
 *      including but not limited to software source code, documentation
 *      source, and configuration files.
 *
 *      "Object" form shall mean any form resulting from mechanical
 *      transformation or translation of a Source form, including but
 *      not limited to compiled object code, generated documentation,
 *      and conversions to other media types.
 *
 *      "Work" shall mean the work of authorship, whether in Source or
 *      Object form, made available under the License, as indicated by a
 *      copyright notice that is included in or attached to the work
 *      (an example is provided in the Appendix below).
 *
 *      "Derivative Works" shall mean any work, whether in Source or Object
 *      form, that is based on (or derived from) the Work and for which the
 *      editorial revisions, annotations, elaborations, or other modifications
 *      represent, as a whole, an original work of authorship. For the purposes
 *      of this License, Derivative Works shall not include works that remain
 *      separable from, or merely link (or bind by name) to the interfaces of,
 *      the Work and Derivative Works thereof.
 *
 *      "Contribution" shall mean any work of authorship, including
 *      the original version of the Work and any modifications or additions
 *      to that Work or Derivative Works thereof, that is intentionally
 *      submitted to Licensor for inclusion in the Work by the copyright owner
 *      or by an individual or Legal Entity authorized to submit on behalf of
 *      the copyright owner. For the purposes of this definition, "submitted"
 *      means any form of electronic, verbal, or written communication sent
 *      to the Licensor or its representatives, including but not limited to
 *      communication on electronic mailing lists, source code control systems,
 *      and issue tracking systems that are managed by, or on behalf of, the
 *      Licensor for the purpose of discussing and improving the Work, but
 *      excluding communication that is conspicuously marked or otherwise
 *      designated in writing by the copyright owner as "Not a Contribution."
 *
 *      "Contributor" shall mean Licensor and any individual or Legal Entity
 *      on behalf of whom a Contribution has been received by Licensor and
 *      subsequently incorporated within the Work.
 *
 *   2. Grant of Copyright License. Subject to the terms and conditions of
 *      this License, each Contributor hereby grants to You a perpetual,
 *      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *      copyright license to reproduce, prepare Derivative Works of,
 *      publicly display, publicly perform, sublicense, and distribute the
 *      Work and such Derivative Works in Source or Object form.
 *
 *   3. Grant of Patent License. Subject to the terms and conditions of
 *      this License, each Contributor hereby grants to You a perpetual,
 *      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *      (except as stated in this section) patent license to make, have made,
 *      use, offer to sell, sell, import, and otherwise transfer the Work,
 *      where such license applies only to those patent claims licensable
 *      by such Contributor that are necessarily infringed by their
 *      Contribution(s) alone or by combination of their Contribution(s)
 *      with the Work to which such Contribution(s) was submitted. If You
 *      institute patent litigation against any entity (including a
 *      cross-claim or counterclaim in a lawsuit) alleging that the Work
 *      or a Contribution incorporated within the Work constitutes direct
 *      or contributory patent infringement, then any patent licenses
 *      granted to You under this License for that Work shall terminate
 *      as of the date such litigation is filed.
 *
 *   4. Redistribution. You may reproduce and distribute copies of the
 *      Work or Derivative Works thereof in any medium, with or without
 *      modifications, and in Source or Object form, provided that You
 *      meet the following conditions:
 *
 *      (a) You must give any other recipients of the Work or
 *          Derivative Works a copy of this License; and
 *
 *      (b) You must cause any modified files to carry prominent notices
 *          stating that You changed the files; and
 *
 *      (c) You must retain, in the Source form of any Derivative Works
 *          that You distribute, all copyright, patent, trademark, and
 *          attribution notices from the Source form of the Work,
 *          excluding those notices that do not pertain to any part of
 *          the Derivative Works; and
 *
 *      (d) If the Work includes a "NOTICE" text file as part of its
 *          distribution, then any Derivative Works that You distribute must
 *          include a readable copy of the attribution notices contained
 *          within such NOTICE file, excluding those notices that do not
 *          pertain to any part of the Derivative Works, in at least one
 *          of the following places: within a NOTICE text file distributed
 *          as part of the Derivative Works; within the Source form or
 *          documentation, if provided along with the Derivative Works; or,
 *          within a display generated by the Derivative Works, if and
 *          wherever such third-party notices normally appear. The contents
 *          of the NOTICE file are for informational purposes only and
 *          do not modify the License. You may add Your own attribution
 *          notices within Derivative Works that You distribute, alongside
 *          or as an addendum to the NOTICE text from the Work, provided
 *          that such additional attribution notices cannot be construed
 *          as modifying the License.
 *
 *      You may add Your own copyright statement to Your modifications and
 *      may provide additional or different license terms and conditions
 *      for use, reproduction, or distribution of Your modifications, or
 *      for any such Derivative Works as a whole, provided Your use,
 *      reproduction, and distribution of the Work otherwise complies with
 *      the conditions stated in this License.
 *
 *   5. Submission of Contributions. Unless You explicitly state otherwise,
 *      any Contribution intentionally submitted for inclusion in the Work
 *      by You to the Licensor shall be under the terms and conditions of
 *      this License, without any additional terms or conditions.
 *      Notwithstanding the above, nothing herein shall supersede or modify
 *      the terms of any separate license agreement you may have executed
 *      with Licensor regarding such Contributions.
 *
 *   6. Trademarks. This License does not grant permission to use the trade
 *      names, trademarks, service marks, or product names of the Licensor,
 *      except as required for reasonable and customary use in describing the
 *      origin of the Work and reproducing the content of the NOTICE file.
 *
 *   7. Disclaimer of Warranty. Unless required by applicable law or
 *      agreed to in writing, Licensor provides the Work (and each
 *      Contributor provides its Contributions) on an "AS IS" BASIS,
 *      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *      implied, including, without limitation, any warranties or conditions
 *      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *      PARTICULAR PURPOSE. You are solely responsible for determining the
 *      appropriateness of using or redistributing the Work and assume any
 *      risks associated with Your exercise of permissions under this License.
 *
 *   8. Limitation of Liability. In no event and under no legal theory,
 *      whether in tort (including negligence), contract, or otherwise,
 *      unless required by applicable law (such as deliberate and grossly
 *      negligent acts) or agreed to in writing, shall any Contributor be
 *      liable to You for damages, including any direct, indirect, special,
 *      incidental, or consequential damages of any character arising as a
 *      result of this License or out of the use or inability to use the
 *      Work (including but not limited to damages for loss of goodwill,
 *      work stoppage, computer failure or malfunction, or any and all
 *      other commercial damages or losses), even if such Contributor
 *      has been advised of the possibility of such damages.
 *
 *   9. Accepting Warranty or Additional Liability. While redistributing
 *      the Work or Derivative Works thereof, You may choose to offer,
 *      and charge a fee for, acceptance of support, warranty, indemnity,
 *      or other liability obligations and/or rights consistent with this
 *      License. However, in accepting such obligations, You may act only
 *      on Your own behalf and on Your sole responsibility, not on behalf
 *      of any other Contributor, and only if You agree to indemnify,
 *      defend, and hold each Contributor harmless for any liability
 *      incurred by, or claims asserted against, such Contributor by reason
 *      of your accepting any such warranty or additional liability.
 *
 *   END OF TERMS AND CONDITIONS
 *
 *   APPENDIX: How to apply the Apache License to your work.
 *
 *      To apply the Apache License to your work, attach the following
 *      boilerplate notice, with the fields enclosed by brackets "[]"
 *      replaced with your own identifying information. (Don't include
 *      the brackets!)  The text should be enclosed in the appropriate
 *      comment syntax for the file format. We also recommend that a
 *      file or class name and description of purpose be included on the
 *      same "printed page" as the copyright notice for easier
 *      identification within third-party archives.
 *
 *   Copyright [yyyy] [name of copyright owner]
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

/*
 * $Id: DefaultDatabase.java,v 1.17 2003/10/15 01:59:47 akarasulu Exp $
 *
 * -- (c) LDAPd Group                                                    --
 * -- Please refer to the LICENSE.txt file in the root directory of      --
 * -- any LDAPd project for copyright and distribution information.      --
 *
 */

package org.apache.ldap.server.backend.db ;


import java.math.BigInteger ;

import java.io.File ;
import java.io.IOException ;

import java.util.Map ;
import java.util.HashMap ;
import java.util.Iterator ;
import java.util.ArrayList ;

import javax.naming.Name ;
import javax.naming.NamingException ; 
import javax.naming.NamingEnumeration ;
import javax.naming.directory.Attribute ;
import javax.naming.directory.Attributes ;
import javax.naming.directory.DirContext ;
import javax.naming.directory.ModificationItem ;

import jdbm.helper.MRU ;
import jdbm.RecordManager ;
import jdbm.recman.BaseRecordManager ;
import jdbm.recman.CacheRecordManager ;

import org.apache.ldap.server.backend.db.index.Index ;
import org.apache.ldap.server.schema.matching.Normalizer ;
import org.apache.ldap.server.backend.db.index.IndexRecord ;
import org.apache.ldap.server.backend.db.index.DefaultIndex ;
import org.apache.ldap.server.schema.attribute.AttributeType ;
import org.apache.ldap.server.backend.db.search.IndexAssertion ;
import org.apache.ldap.server.backend.db.table.DefaultMasterTable ;
import org.apache.ldap.server.backend.db.search.IndexAssertionEnumeration ;

import org.apache.ldap.common.name.LdapName ;
import org.apache.ldap.common.MultiException ;
import org.apache.ldap.common.util.NamespaceTools ;
import org.apache.ldap.common.message.LockableAttributesImpl ;


/**
 * A Database implementation based on JDBM B+Tree implementation.
 *
 * @author <a href="mailto:aok123@bellsouth.net">Alex Karasulu</a>
 * @author $Author: akarasulu $
 * @version $Revision: 1.17 $
 */
public class DefaultDatabase
    implements Database
{
    /** the JDBM record manager used by this database */
    private final RecordManager m_recMan ;
    /** the suffix of this backend database */
    private final Name m_suffix ;
    /** the working directory to use for files */
    private final String m_wkdir ;
    /** the master table storing entries by primary key */
    private final DefaultMasterTable m_master ;
    /** a map of attribute names to user indices */
    private final Map m_indices ;
    /** a map of index names to system indices */
    private final Map m_sysIndices ;

    /** the normalized distinguished name index */
    private Index m_ndnIdx ;
    /** the user provided distinguished name index */
    private Index m_updnIdx ;
    /** the attribute existance index */
    private Index m_existanceIdx ;
    /** the parent child relationship index */
    private Index m_heirarchyIdx ;
    /** the one level scope alias index */
    private Index m_oneAliasIdx ;
    /** the subtree scope alias index */
    private Index m_subAliasIdx ;
    /** a system index on aliasedObjectName attribute */
    private Index m_aliasIdx ;

    /**
     * Creates a Databased based on JDBM B+Trees.
     *
     * @param a_suffix the user provided suffix name 
     * @param a_wkdirPath the path to the working directory where the db resides
     * @throws NamingException if db cannot be created
     */
    public DefaultDatabase ( final Name a_suffix, final String a_wkdirPath ) 
        throws NamingException
    {
        m_suffix = a_suffix ;
        m_wkdir = a_wkdirPath ;

        try 
        {
            String l_path = a_wkdirPath + File.separator + "master" ;
            BaseRecordManager l_base = new BaseRecordManager( l_path ) ;
            l_base.disableTransactions() ;
            m_recMan = new CacheRecordManager( l_base, new MRU( 1000 ) ) ;
        } 
        catch ( IOException e )
        {
            NamingException l_ne = new NamingException( 
                "Could not initialize RecordManager" ) ;
            l_ne.setRootCause( e ) ;
            throw l_ne ;
        }

        m_master = new DefaultMasterTable( m_recMan ) ;
        m_indices = new HashMap() ;
        m_sysIndices = new HashMap() ;
    }


    /**
     * @see org.apache.ldap.server.backend.Database#addIndexOn(
     * org.apache.ldap.server.schema.AttributeTypeImpl)
     */
    public void addIndexOn( AttributeType a_spec )
        throws NamingException
    {
        Index l_idx = new DefaultIndex( a_spec, m_wkdir ) ;
        String l_id = a_spec.getName() ;
        m_indices.put( a_spec.getName().toLowerCase(), l_idx ) ;
    }

    
    /**
     * @see org.apache.ldap.server.backend.Database#getExistanceIndex()
     */
    public Index getExistanceIndex() 
    {
        return m_existanceIdx ;
    }
    

    /**
     * Sets the attribute existance Index.
     *
     * @param a_idx the attribute existance Index 
     */    
    public void setExistanceIndex( Index a_idx )
    {
        m_existanceIdx = a_idx ;
        m_sysIndices.put( a_idx.getAttribute().getName().toLowerCase(), 
            a_idx ) ;
    }

    
    /**
     * @see org.apache.ldap.server.backend.Database#getHeirarchyIndex()
     */
    public Index getHeirarchyIndex() 
    {
        return m_heirarchyIdx ;
    }
    

    /**
     * Sets the heirarchy Index.
     *
     * @param a_idx the heirarchy Index 
     */    
    public void setHeirarchyIndex( Index a_idx )
    {
        m_heirarchyIdx = a_idx ;
        m_sysIndices.put( a_idx.getAttribute().getName().toLowerCase()
            , a_idx ) ;
    }

    
    /**
     * @see org.apache.ldap.server.backend.Database#getUpdnIndex()
     */    
    public Index getUpdnIndex() 
    {
        return m_updnIdx ;
    }

    
    /**
     * @see org.apache.ldap.server.backend.db.Database#getAliasIndex()
     */
    public Index getAliasIndex()
    {
        return m_aliasIdx ;    
    }


    /**
     * @see org.apache.ldap.server.backend.db.Database#setAliasIndex(
     * org.apache.ldap.server.backend.db.index.Index)
     */
    public void setAliasIndex( Index a_idx )
    {
        m_aliasIdx = a_idx ; 
        m_sysIndices.put( a_idx.getAttribute().getName().toLowerCase(), 
            a_idx ) ;
    }    
    

    /**
     * @see org.apache.ldap.server.backend.db.Database#getOneAliasIndex()
     */
    public Index getOneAliasIndex()
    {
        return m_oneAliasIdx ;
    }


    /**
     * @see org.apache.ldap.server.backend.db.Database#setOneAliasIndex(
     * org.apache.ldap.server.backend.db.index.Index)
     */
    public void setOneAliasIndex( Index a_idx )
    {
        m_oneAliasIdx = a_idx ;
        m_sysIndices.put( a_idx.getAttribute().getName().toLowerCase(), 
            a_idx ) ;
    }


    /**
     * @see org.apache.ldap.server.backend.db.Database#getSubAliasIndex()
     */
    public Index getSubAliasIndex()
    {
        return m_subAliasIdx ;
    }


    /**
     * @see org.apache.ldap.server.backend.db.Database#setSubAliasIndex(
     * org.apache.ldap.server.backend.db.index.Index)
     */
    public void setSubAliasIndex( Index a_idx )
    {
        m_subAliasIdx = a_idx ;
        m_sysIndices.put( a_idx.getAttribute().getName().toLowerCase(), 
            a_idx ) ;
    }


    /**
     * Sets the user provided distinguished name Index.
     *
     * @param a_idx the updn Index 
     */    
    public void setUpdnIndex( Index a_idx )
    {
        m_updnIdx = a_idx ;
        m_sysIndices.put( a_idx.getAttribute().getName().toLowerCase(), 
            a_idx ) ;
    }

    
    /**
     * @see org.apache.ldap.server.backend.Database#getNdnIndex()
     */
    public Index getNdnIndex() 
    {
        return m_ndnIdx ;
    }
    

    /**
     * Sets the normalized distinguished name Index.
     *
     * @param a_idx the ndn Index 
     */    
    public void setNdnIndex( Index a_idx )
    {
        m_ndnIdx = a_idx ;
        m_sysIndices.put( a_idx.getAttribute().getName().toLowerCase(), 
            a_idx ) ;
    }

    
    /**
     * @see org.apache.ldap.server.backend.Database#getUserIndices()
     */
    public Iterator getUserIndices()
    {
        return m_indices.keySet().iterator() ;
    }


    /**
     * @see org.apache.ldap.server.backend.Database#getSystemIndices()
     */
    public Iterator getSystemIndices()
    {
        return m_sysIndices.keySet().iterator() ;
    }


    /**
     * @see org.apache.ldap.server.backend.db.Database#hasUserIndexOn(java.lang.String)
     */
    public boolean hasUserIndexOn( String an_attribute )
    {
        return 
            m_indices.containsKey( an_attribute ) ||
            m_indices.containsKey( an_attribute.toLowerCase() ) ;
    }


    /**
     * @see org.apache.ldap.server.backend.db.Database#hasSystemIndexOn(java.lang.String)
     */
    public boolean hasSystemIndexOn( String an_attribute )
    {
        return 
            m_sysIndices.containsKey( an_attribute ) ||
            m_sysIndices.containsKey( an_attribute.toLowerCase() ) ;
    }


    /**
     * @todo replace lookups to use the OID instead of the name.  Also note
     * that the OID registry can be used to go between names and oids.
     * 
     * @see org.apache.ldap.server.backend.Database#getIndex(java.lang.String)
     */
    public Index getUserIndex( String an_attribute )
        throws IndexNotFoundException
    {
        String l_lowerCased = an_attribute.toLowerCase() ;

        if ( m_indices.containsKey( an_attribute ) ) 
        {
            return ( Index ) m_indices.get( an_attribute ) ;
        } 
        else if ( m_indices.containsKey( l_lowerCased ) ) 
        {
            return ( Index ) m_indices.get( l_lowerCased ) ;
        } 
        else 
        {
            throw new IndexNotFoundException( "An index on attribute " +
                an_attribute + " does not exist!" ) ;
        }
    }
    
    
    /**
     * @todo replace lookups to use the OID instead of the name.  Also note
     * that the OID registry can be used to go between names and oids.
     * 
     * @see org.apache.ldap.server.backend.db.Database#getEntryId(java.lang.String)
     */
    public Index getSystemIndex( String a_indexName )
        throws IndexNotFoundException
    {
        String l_lowerCased = a_indexName.toLowerCase() ;

        if ( m_sysIndices.containsKey( a_indexName ) ) 
        {
            return ( Index ) m_sysIndices.get( a_indexName ) ;
        } 
        else if ( m_sysIndices.containsKey( l_lowerCased ) ) 
        {
            return ( Index ) m_sysIndices.get( l_lowerCased ) ;
        } 
        else 
        {
            throw new IndexNotFoundException( "A system index by the name of " +
                a_indexName + " does not exist!" ) ;
        }
    }


    /**
     * @see org.apache.ldap.server.backend.Database#getEntryId(java.lang.String)
     */
    public BigInteger getEntryId( String a_dn )
        throws NamingException
    {
        return m_ndnIdx.forwardLookup( a_dn ) ;
    }


    /**
     * @see org.apache.ldap.server.backend.Database#getEntryDn(java.math.BigInteger)
     */
    public String getEntryDn( BigInteger a_id )
        throws NamingException
    {
        return ( String ) m_ndnIdx.reverseLookup( a_id ) ;
    }


    /**
     * @see org.apache.ldap.server.backend.Database#getParentId(java.lang.String)
     */
    public BigInteger getParentId( String a_dn )
        throws  NamingException
    {
        BigInteger l_childId = m_ndnIdx.forwardLookup( a_dn ) ;
        return ( BigInteger ) m_heirarchyIdx.reverseLookup( l_childId ) ;
    }


    /**
     * @see org.apache.ldap.server.backend.Database#getParentId(java.math.BigInteger)
     */
    public BigInteger getParentId( BigInteger a_childId )
        throws NamingException
    {
        return ( BigInteger ) m_heirarchyIdx.reverseLookup( a_childId ) ;
    }
    
    
    /**
     * @see org.apache.ldap.server.backend.Database#getEntryUpdn(java.math.BigInteger)
     */
    public String getEntryUpdn( BigInteger a_id )
        throws NamingException
    {
        return ( String ) m_updnIdx.reverseLookup( a_id ) ;
    }


    /**
     * @see org.apache.ldap.server.backend.Database#getEntryUpdn(java.lang.String)
     */
    public String getEntryUpdn( String a_dn )
        throws NamingException
    {
        BigInteger l_id = m_ndnIdx.forwardLookup( a_dn ) ;
        return ( String ) m_updnIdx.reverseLookup( l_id ) ;
    }


    /**
     * @see org.apache.ldap.server.backend.Database#count()
     */
    public int count()
        throws NamingException
    {
        return m_master.count() ;
    }
    
    
    /**
     * Removes the index entries for an alias before the entry is deleted from
     * the master table.
     * 
     * @todo Optimize this by walking the heirarchy index instead of the name 
     * @param a_aliasId the id of the alias entry in the master table
     * @throws NamingException if we cannot delete the indices
     */
    private void dropAliasIndices( BigInteger a_aliasId ) throws NamingException
    {
        String l_targetDn = ( String ) m_aliasIdx.reverseLookup( a_aliasId ) ;
        BigInteger l_targetId = getEntryId( l_targetDn ) ;
        String l_aliasDn = getEntryDn( a_aliasId ) ;
        Name l_ancestorDn = new LdapName( l_aliasDn ).getSuffix( 1 ) ;
        BigInteger l_ancestorId = getEntryId( l_ancestorDn.toString() ) ;
        
        /*
         * We cannot just drop all tuples in the one level and subtree indices
         * linking baseIds to the l_targetId.  If more than one alias refers to
         * the target then droping all tuples with a value of targetId would
         * make all other aliases to the target inconsistent.
         * 
         * We need to walk up the path of alias ancestors until we reach the 
         * suffix, deleting each ( l_ancestorId, l_targetId ) tuple in the 
         * subtree scope alias.  We only need to do this for the direct parent
         * of the alias on the one level subtree.
         */
        m_oneAliasIdx.drop( l_ancestorId, l_targetId ) ;
        m_subAliasIdx.drop( l_ancestorId, l_targetId ) ;
        
        while ( ! l_ancestorDn.equals( m_suffix ) )
        {
            l_ancestorDn = l_ancestorDn.getSuffix( 1 ) ;
            l_ancestorId = getEntryId( l_ancestorDn.toString() ) ;
            
            m_subAliasIdx.drop( l_ancestorId, l_targetId ) ;
        }    

        // Drops all alias tuples pointing to the id of the alias to be deleted
        m_aliasIdx.drop( a_aliasId ) ;
    }
    
    
    /**
     * Adds indices for an aliasEntry to be added to the database while checking
     * for constrained alias constructs like alias cycles and chaining.
     * 
     * @param a_aliasDn normalized distinguished name for the alias entry
     * @param a_aliasTarget the user provided aliased entry dn as a string
     * @param a_aliasId the id of alias entry to add
     * @throws NamingException if index addition fails, of the alias is not 
     * allowed due to chaining or cycle formation.
     */
    private void addAliasIndices( BigInteger a_aliasId, Name a_aliasDn, 
        String a_aliasTarget ) throws NamingException
        // Attributes a_aliasEntry ) throws NamingException
    {
        Name l_targetDn = null ;            // Name value of aliasedObjectName
        Attributes l_target = null ;        // Attributes of the target entry
        BigInteger l_targetId = null ;      // Id of the aliasedObjectName
        Normalizer l_normalizer = null ;    // Temporary handle for Dn's
        Name l_ancestorDn = null ;          // Name of an alias entry relative
        BigInteger l_ancestorId = null ;    // Id of an alias entry relative

        // Access aliasedObjectName, normalize it and generate the Name 
        l_normalizer = m_oneAliasIdx.getAttribute().getNormalizer() ;
        l_targetDn = new LdapName( ( String ) 
            l_normalizer.normalize( a_aliasTarget ) ) ;
           
        /*
         * Check For Cycles
         * 
         * Before wasting time to lookup more values we check using the target
         * dn to see if we have the possible formation of an alias cycle.  This
         * happens when the alias refers back to a target that is also a 
         * relative of the alias entry.  For detection we test if the aliased
         * entry Dn starts with the target Dn.  If it does then we know the 
         * aliased target is a relative and we have a perspecitive cycle.
         */ 
        if ( a_aliasDn.startsWith( l_targetDn ) )
        {
            if ( a_aliasDn.equals( l_targetDn ) )
            {
                throw new NamingException( "[36] aliasDereferencingProblem - " 
                    + "attempt to create alias to itself." ) ;
            }
            
            throw new NamingException( "[36] aliasDereferencingProblem - " 
                + "attempt to create alias with cycle to relative " 
                + a_aliasTarget + " not allowed from descendent alias " 
                + a_aliasDn ) ;
        }
            
        /*
         * Check For Aliases External To Naming Context
         * 
         * l_id may be null but the alias may be to a valid entry in 
         * another namingContext.  Such aliases are not allowed and we
         * need to point it out to the user instead of saying the target
         * does not exist when it potentially could outside of this suffix.
         */
        if ( ! l_targetDn.startsWith( m_suffix ) )
        {
            // Complain specifically about aliases to outside naming contexts
            throw new NamingException( "[36] aliasDereferencingProblem -"
                + " the alias points to an entry outside of the " + m_suffix
                + " namingContext to an object whose existance cannot be"
                + " determined." ) ;
        }

        // L O O K U P   T A R G E T   I D
        l_targetId = m_ndnIdx.forwardLookup( l_targetDn.toString() ) ;

        /*
         * Check For Target Existance
         * 
         * We do not allow the creation of inconsistant aliases.  Aliases should
         * not be broken links.  If the target does not exist we start screaming
         */
        if ( null == l_targetId )
        {
            // Complain about target not existing
            throw new NamingException( "[33] aliasProblem - " 
                + "the alias when dereferenced would not name a known object "
                + "the aliasedObjectName must be set to a valid existing "
                + "entry." ) ;
        }
        
        /*
         * Detect Direct Alias Chain Creation
         * 
         * Rather than resusitate the target to test if it is an alias and fail
         * due to chaing creation we use the alias index to determine if the
         * target is an alias.  Hence if the alias we are about to create points
         * to another alias as its target in the aliasedObjectName attribute, 
         * then we have a situation where an alias chain is being created.  
         * Alias chaining is not allowed so we throw and exception. 
         */
        if ( null != m_aliasIdx.reverseLookup( l_targetId ) )
        {
            // Complain about illegal alias chain
            throw new NamingException( "[36] aliasDereferencingProblem -" 
                + " the alias points to another alias.  Alias chaining is" 
                + " not supported by this backend." ) ;
        }
        
        // Add the alias to the simple alias index
        m_aliasIdx.add( a_aliasTarget, a_aliasId ) ;
        
        /*
         * Handle One Level Scope Alias Index
         * 
         * The first relative is special with respect to the one level alias
         * index.  If the target is not a sibling of the alias then we add the
         * index entry maping the parent's id to the aliased target id.
         */
        l_ancestorDn = a_aliasDn.getSuffix( 1 ) ;
        l_ancestorId = getEntryId( l_ancestorDn.toString() ) ;
        
        if ( ! NamespaceTools.isSibling( l_targetDn, a_aliasDn ) )
        {
            m_oneAliasIdx.add( l_ancestorId, l_targetId ) ;
        }

        /*
         * Handle Sub Level Scope Alias Index
         * 
         * Walk the list of relatives from the parents up to the suffix, testing
         * to see if the alias' target is a descendant of the relative.  If the
         * alias target is not a descentant of the relative it extends the scope
         * and is added to the sub tree scope alias index.  The suffix node is
         * ignored since everything is under its scope.  The first loop 
         * iteration shall handle the parents.
         */
        while ( ! l_ancestorDn.equals( m_suffix ) && null != l_ancestorId )
        {
            if ( ! NamespaceTools.isDescendant( l_ancestorDn, l_targetDn ) )
            {
                m_subAliasIdx.add( l_ancestorId, l_targetId ) ;
            }
            
            l_ancestorDn = l_ancestorDn.getSuffix( 1 ) ;
            l_ancestorId = getEntryId( l_ancestorDn.toString() ) ;
        }        
    }


    /**
     * @see org.apache.ldap.server.backend.Database#add(javax.naming.Name, 
     * javax.naming.directory.Attributes)
     */
    public void add( String a_updn, Name a_dn, Attributes an_entry )
        throws NamingException
    {
        BigInteger l_id = m_master.getNextId() ;
        BigInteger l_parentId = null ;
        
        //
        // Suffix entry cannot have a parent since it is the root so it is 
        // capped off using the zero value which no entry can have since 
        // entry sequences start at 1.
        //
        
        if ( a_dn.equals( m_suffix ) )
        {
            l_parentId = BigInteger.ZERO ;
        }
        else 
        {
            l_parentId = getEntryId( a_dn.getSuffix( 1 ).toString() ) ;
        }
        
        // Start adding the system indices
        // Why bother doing a lookup if this is not an alias.
        if ( an_entry.get( "objectClass" ).contains( ALIAS_OBJECT ) ) 
        {
            addAliasIndices( l_id, a_dn, 
                ( String ) an_entry.get( ALIAS_ATTRIBUTE ).get() ) ;
        }
        
        m_ndnIdx.add( a_dn.toString(), l_id ) ;
        m_updnIdx.add( a_updn, l_id ) ;
        m_heirarchyIdx.add( l_parentId, l_id ) ;
        
        // Now work on the user defined indices
        NamingEnumeration l_list = an_entry.getIDs() ;
        while ( l_list.hasMore() ) 
        {
            String l_attribute = ( String ) l_list.next() ;
            
            if ( hasUserIndexOn( l_attribute ) ) 
            {
                Index l_idx = getUserIndex( l_attribute ) ;
                NamingEnumeration l_values = 
                    an_entry.get( l_attribute ).getAll() ;
                
                while ( l_values.hasMore() ) 
                {
                    l_idx.add( l_values.next(), l_id ) ;
                }

                // Adds only those attributes that are indexed
                m_existanceIdx.add( l_attribute.toLowerCase(), l_id ) ;
            }
        }

        m_master.put( an_entry, l_id ) ;
    }


    /**
     * @see org.apache.ldap.server.backend.Database#lookup(java.math.BigInteger)
     */
    public Attributes lookup( BigInteger a_id ) throws NamingException
    {
        return m_master.get( a_id ) ;
    }


    /**
     * @see org.apache.ldap.server.backend.Database#delete(java.math.BigInteger)
     */
    public void delete( BigInteger a_id )
        throws  NamingException
    {
        Attributes l_entry = lookup( a_id ) ;
        BigInteger l_parentId = getParentId( a_id ) ; 
        String l_dn = getEntryDn( a_id ) ;
        NamingEnumeration l_attrs = l_entry.getIDs() ;
        
        if ( l_entry.get( "objectClass" ).contains( ALIAS_OBJECT ) )
        {
            dropAliasIndices( a_id ) ;
        }

        m_ndnIdx.drop( a_id ) ;
        m_updnIdx.drop( a_id ) ;
        m_heirarchyIdx.drop( a_id ) ;
        
        // Remove parent's reference to entry only if entry is not the suffix  
        if ( ! l_parentId.equals( BigInteger.ZERO ) )
        {
            m_heirarchyIdx.drop( l_parentId, a_id ) ;
        }
        
        while ( l_attrs.hasMore() ) 
        {
            String l_attr = ( ( String ) l_attrs.next() ) ;

            if ( hasUserIndexOn( l_attr ) )
            {
                Index l_index = ( Index ) getUserIndex( l_attr ) ;
                NamingEnumeration l_values = l_entry.get( l_attr ).getAll() ;
                
                while ( l_values.hasMore() )
                {
                    l_index.drop( l_values.next(), a_id ) ;
                }

                m_existanceIdx.drop( l_attr.toLowerCase(), a_id ) ;
            }
        }

        m_master.delete( a_id ) ;
    }


    /**
     * @see org.apache.ldap.server.backend.Database#list(java.math.BigInteger)
     */
    public NamingEnumeration list( BigInteger a_id )
        throws  NamingException
    {
        return m_heirarchyIdx.listIndices( a_id ) ;
    }


    /**
     * @see org.apache.ldap.server.backend.Database#getChildCount(java.math.BigInteger)
     */
    public int getChildCount( BigInteger a_id )
        throws  NamingException
    {
        return m_heirarchyIdx.count( a_id ) ;
    }


    /**
     * @see org.apache.ldap.server.backend.Database#getSuffix()
     */
    public Name getSuffix()
    {
        return m_suffix ;
    }


    /**
     * @see org.apache.ldap.server.backend.Database#getSuffixEntry()
     */
    public Attributes getSuffixEntry()
        throws  NamingException
    {
        BigInteger l_id = getEntryId( m_suffix.toString() ) ;

        if ( null == l_id )
        {
            return null ;
        }

        return lookup( l_id ) ;
    }


    /**
     * @see org.apache.ldap.server.backend.Database#sync()
     */
    public void sync()
        throws NamingException
    {
        ArrayList l_array = new ArrayList() ;
        l_array.addAll( m_indices.values() ) ;
        l_array.add( m_ndnIdx ) ;
        l_array.add( m_updnIdx ) ;
        l_array.add( m_aliasIdx ) ;
        l_array.add( m_oneAliasIdx ) ;
        l_array.add( m_subAliasIdx ) ;
        l_array.add( m_heirarchyIdx ) ;
        l_array.add( m_existanceIdx ) ;
        
        Iterator l_list = l_array.iterator() ;
        MultiException l_rootCause = null ;

        // Sync all user defined indices
        while ( l_list.hasNext() ) 
        {
            Index l_idx = ( Index ) l_list.next() ;

            try 
            {
                l_idx.sync() ;
            } 
            catch ( Throwable t ) 
            {
                if ( null == l_rootCause ) 
                {
                    l_rootCause = new MultiException() ;
                }
                
                l_rootCause.addThrowable( t ) ;
            }
        }
        
        try 
        {
            m_master.sync() ;
        } 
        catch ( Throwable t ) 
        {
            if ( null == l_rootCause ) 
            {
                l_rootCause = new MultiException() ;
            }
                
            l_rootCause.addThrowable( t ) ;
        }


        if ( null != l_rootCause )
        {
            NamingException l_ne = new NamingException( "Failed to sync all" ) ;
            l_ne.setRootCause( l_rootCause ) ;
            throw l_ne ;
        }        
    }


    /**
     * @see org.apache.ldap.server.backend.Database#close()
     */
    public void close()
        throws NamingException
    {
        ArrayList l_array = new ArrayList() ;
        l_array.addAll( m_indices.values() ) ;
        
        if ( null != m_ndnIdx )
        {
            l_array.add( m_ndnIdx ) ;
        }
        
        if ( null != m_updnIdx )
        {
            l_array.add( m_updnIdx ) ;
        }

        if ( null != m_aliasIdx )
        {
            l_array.add( m_aliasIdx ) ;
        }

        if ( null != m_oneAliasIdx )
        {
            l_array.add( m_oneAliasIdx ) ;
        }

        if ( null != m_subAliasIdx )
        {
            l_array.add( m_subAliasIdx ) ;
        }

        if ( null != m_heirarchyIdx )
        {
            l_array.add( m_heirarchyIdx ) ;
        }

        if ( null != m_existanceIdx )
        {
            l_array.add( m_existanceIdx ) ;
        }
        
        Iterator l_list = l_array.iterator() ;
        MultiException l_rootCause = null ;
        
        while ( l_list.hasNext() ) 
        {
            Index l_index = ( Index ) l_list.next() ;

            try 
            {
               l_index.close() ;
            } 
            catch ( Throwable t ) 
            {
                if ( null == l_rootCause ) 
                {
                    l_rootCause = new MultiException() ;
                }
                
                l_rootCause.addThrowable( t ) ;
            }
        }

        try 
        {
            m_master.close() ;
        } 
        catch ( Throwable t ) 
        {
            if ( null == l_rootCause ) 
            {
                l_rootCause = new MultiException() ;
            }
                
            l_rootCause.addThrowable( t ) ;
        }

        try 
        {
            m_recMan.close() ;
        } 
        catch ( Throwable t ) 
        {
            if ( null == l_rootCause ) 
            {
                l_rootCause = new MultiException() ;
            }
                
            l_rootCause.addThrowable( t ) ;
        }

        if ( null != l_rootCause )
        {
            NamingException l_ne = 
                new NamingException( "Failed to close all" ) ;
            l_ne.setRootCause( l_rootCause ) ;
            throw l_ne ;
        }        
    }


    /**
     * @see org.apache.ldap.server.backend.Database#setProperty(java.lang.String, 
     * java.lang.String)
     */
    public void setProperty( String a_propertyName, String a_propertyValue )
        throws NamingException
    {
        m_master.setProperty( a_propertyName, a_propertyValue ) ;
    }


    /**
     * @see org.apache.ldap.server.backend.Database#getProperty(java.lang.String)
     */
    public String getProperty( String a_propertyName )
        throws NamingException
    {
        return m_master.getProperty( a_propertyName ) ;
    }


    /**
     * @see org.apache.ldap.server.backend.Database#getIndices(java.math.BigInteger)
     */
    public Attributes getIndices( BigInteger a_id )
        throws  NamingException
    {
        Attributes l_attributes = new LockableAttributesImpl() ;

        // Get the distinguishedName to id mapping
        l_attributes.put( "_nDn", getEntryDn( a_id ) ) ;
        l_attributes.put( "_upDn", getEntryUpdn( a_id ) ) ;
        l_attributes.put( "_parent", getParentId( a_id ) ) ;

        // Get all standard index attribute to value mappings
        Iterator l_indices = m_indices.values().iterator() ;
        while ( l_indices.hasNext() ) 
        {
            Index l_index = ( Index ) l_indices.next() ;
            NamingEnumeration l_list = l_index.listReverseIndices( a_id ) ;
            while ( l_list.hasMore() ) 
            {
                IndexRecord l_rec = ( IndexRecord ) l_list.next() ;
                Object l_val = l_rec.getIndexKey() ;
                l_attributes.put( l_index.getAttribute().getName(), l_val ) ;
            }
        }

        // Get all existance mappings for this id creating a special key
        // that looks like so 'existance[attribute]' and the value is set to id
        NamingEnumeration l_list = m_existanceIdx.listReverseIndices( a_id ) ;
        StringBuffer l_val = new StringBuffer() ;
        while ( l_list.hasMore() ) 
        {
            IndexRecord l_rec = ( IndexRecord ) l_list.next() ;
            l_val.append( "_existance[" ) ; 
            l_val.append( l_rec.getIndexKey() ) ;
            l_val.append( ']' ) ;
            l_attributes.put( l_val.toString(), l_rec.getEntryId() ) ;
            l_val.setLength( 0 ) ;
        }

        // Get all parent child mappings for this entry as the parent using the
        // key 'child' with many entries following it.
        l_list = m_heirarchyIdx.listIndices( a_id ) ;
        while ( l_list.hasMore() ) 
        {
            IndexRecord l_rec = ( IndexRecord ) l_list.next() ;
            l_attributes.put( "_child", l_rec.getEntryId() ) ;
        }

        return l_attributes ;
    }


    /**
     * Adds a set of attribute values while affecting the appropriate indices. 
     * The entry is not persisted: it is only changed in anticipation for a put 
     * into the master table.
     *
     * @param a_id the primary key of the entry
     * @param a_entry the entry to alter
     * @param a_mods the attribute and values to add 
     * @throws NamingException if index alteration or attribute addition
     * fails.
     */
    private void add( BigInteger a_id, Attributes a_entry, Attribute a_mods )
        throws NamingException 
    {
        if ( hasUserIndexOn( a_mods.getID() ) )
        {
            Index l_idx = getUserIndex( a_mods.getID() ) ;
            l_idx.add( a_mods, a_id ) ;

            // If the attr didn't exist for this id add it to existance index
            if ( ! m_existanceIdx.hasValue( a_mods.getID(), a_id ) )
            {
                l_idx.add( a_mods.getID(), a_id ) ;
            }
        }
        
        a_entry.put( a_mods ) ;

        if ( a_mods.getID().equals( ALIAS_ATTRIBUTE ) )
        {
            String l_ndnStr = ( String ) m_ndnIdx.reverseLookup( a_id ) ;
            addAliasIndices( a_id, new LdapName( l_ndnStr ), 
                ( String ) a_mods.get() ) ;
        }
    }
    
    
    /**
     * Completely removes the set of values for an attribute having the values 
     * supplied while affecting the appropriate indices.  The entry is not 
     * persisted: it is only changed in anticipation for a put into the master 
     * table.  Note that an empty attribute w/o values will remove all the 
     * values within the entry where as an attribute w/ values will remove those
     * attribute values it contains.
     *
     * @param a_id the primary key of the entry
     * @param a_entry the entry to alter
     * @param a_mods the attribute and its values to delete
     * @throws NamingException if index alteration or attribute modification 
     * fails.
     */
    private void remove( BigInteger a_id, Attributes a_entry, Attribute a_mods )
        throws NamingException
    {
        if ( hasUserIndexOn( a_mods.getID() ) )
        {
            Index l_idx = getUserIndex( a_mods.getID() ) ;
            l_idx.drop( a_mods, a_id ) ;
    
            /* 
             * If no attribute values exist for this entryId in the index then
             * we remove the existance index entry for the removed attribute.
             */
            if ( null == l_idx.reverseLookup( a_id ) )
            {
                m_existanceIdx.drop( a_mods.getID(), a_id ) ;
            }
        }

        /*
         * If there are no attribute values in the modifications then this 
         * implies the compelete removal of the attribute from the entry. Else
         * we remove individual attribute values from the entry in a_mods one 
         * at a time.
         */
        if ( a_mods.size() == 0 )
        {
            a_entry.remove( a_mods.getID() ) ;
        }
        else
        {
            Attribute l_entryAttr = a_entry.get( a_mods.getID() ) ;
            NamingEnumeration l_values = a_mods.getAll() ;
            while ( l_values.hasMore() ) 
            {
                l_entryAttr.remove( l_values.next() ) ;
            }
        }

        // Aliases->single valued comp/partial attr removal is not relevant here
        if ( a_mods.getID().equals( ALIAS_ATTRIBUTE ) )
        {
            dropAliasIndices( a_id ) ;
        }
    }


    /**
     * Completely replaces the existing set of values for an attribute with the
     * modified values supplied affecting the appropriate indices.  The entry
     * is not persisted: it is only changed in anticipation for a put into the
     * master table.
     *
     * @param a_id the primary key of the entry
     * @param a_entry the entry to alter
     * @param a_mods the replacement attribute and values
     * @throws NamingException if index alteration or attribute modification 
     * fails.
     */
    private void replace( BigInteger a_id, Attributes a_entry, 
        Attribute a_mods ) throws NamingException
    {
        if ( hasUserIndexOn( a_mods.getID() ) )
        {
            Index l_idx = getUserIndex( a_mods.getID() ) ;
            
            // Drop all existing attribute value index entries and add new ones
            l_idx.drop( a_id ) ;
            l_idx.add( a_mods, a_id ) ;
    
            /* 
             * If no attribute values exist for this entryId in the index then
             * we remove the existance index entry for the removed attribute.
             */
            if ( null == l_idx.reverseLookup( a_id ) )
            {
                m_existanceIdx.drop( a_mods.getID(), a_id ) ;
            }
        }

        if ( a_mods.getID().equals( ALIAS_ATTRIBUTE ) )
        {
            dropAliasIndices( a_id ) ;
        }
        
        // Automatically replaces old attributes with new modified ones
        a_entry.put( a_mods ) ;
        
        if ( a_mods.getID().equals( ALIAS_ATTRIBUTE ) )
        {
            String l_ndnStr = ( String ) m_ndnIdx.reverseLookup( a_id ) ;
            addAliasIndices( a_id, new LdapName( l_ndnStr ), 
                ( String ) a_mods.get() ) ;
        }
    }


    /**
     * @see org.apache.ldap.server.backend.Database#modify(javax.naming.Name, int, 
     * javax.naming.directory.Attributes)
     */
    public void modify( Name a_dn, int a_modOp, Attributes a_mods ) 
        throws NamingException 
    {
        NamingEnumeration l_attrs = null ;
        BigInteger l_id = getEntryId( a_dn.toString() ) ;
        Attributes l_entry = m_master.get( l_id ) ;
        
        switch ( a_modOp )
        {
            case( DirContext.ADD_ATTRIBUTE ):
                l_attrs = a_mods.getIDs() ;
                
                while ( l_attrs.hasMore() )
                {
                    String l_attrId = ( String ) l_attrs.next() ;
                    Attribute l_attr = a_mods.get( l_attrId ) ;
                    add( l_id, l_entry, l_attr ) ;
                }
                
                break ;
            case( DirContext.REMOVE_ATTRIBUTE ):
                l_attrs = a_mods.getIDs() ;
                
                while ( l_attrs.hasMore() )
                {
                    String l_attrId = ( String ) l_attrs.next() ;
                    Attribute l_attr = a_mods.get( l_attrId ) ;
                    remove( l_id, l_entry, l_attr ) ;
                }
                
                break ;
            case( DirContext.REPLACE_ATTRIBUTE ):
                l_attrs = a_mods.getIDs() ;
                
                while ( l_attrs.hasMore() )
                {
                    String l_attrId = ( String ) l_attrs.next() ;
                    Attribute l_attr = a_mods.get( l_attrId ) ;
                    replace( l_id, l_entry, l_attr ) ;
                }
                
                break ;
            default:
                throw new NamingException( 
                    "Unidentified modification operation" ) ;
        }
        
        m_master.put( l_entry, l_id ) ;
    }
    

    /**
     * @see org.apache.ldap.server.backend.Database#modify(javax.naming.Name, 
     * javax.naming.directory.ModificationItem[])
     */
    public void modify( Name a_dn, ModificationItem [] a_mods ) 
        throws NamingException 
    {
        NamingEnumeration l_attrs = null ;
        BigInteger l_id = getEntryId( a_dn.toString() ) ;
        Attributes l_entry = m_master.get( l_id ) ;
        
        for ( int ii = 0; ii < a_mods.length ; ii++ )
        {
            Attribute l_attrMods = a_mods[ii].getAttribute() ;

            switch ( a_mods[ ii ].getModificationOp() )
            {
                case( DirContext.ADD_ATTRIBUTE ):
                    add( l_id, l_entry, l_attrMods ) ;
                    break ;
                case( DirContext.REMOVE_ATTRIBUTE ):
                    remove( l_id, l_entry, l_attrMods ) ;
                    break ;
                case( DirContext.REPLACE_ATTRIBUTE ):
                    replace( l_id, l_entry, l_attrMods ) ;
                    break ;
                default:
                    throw new NamingException( 
                        "Unidentified modification operation" ) ;
            }
        }
        
        m_master.put( l_entry, l_id ) ;
    }


    /**
     * Changes the relative distinuished name of an entry specified by a 
     * distinguished name with the optional removal of the old Rdn attribute
     * value from the entry.  Name changes propagate down as dn changes to the 
     * descendants of the entry where the Rdn changed. 
     * 
     * An Rdn change operation does not change parent child relationships.  It 
     * merely propagates a name change at a point in the DIT where the Rdn is 
     * changed. The change propagates down the subtree rooted at the 
     * distinguished name specified.
     *
     * @param a_dn the normalized distinguished name of the entry to alter
     * @param a_newRdn the new Rdn to set
     * @param a_deleteOldRdn whether or not to remove the old Rdn attr/val
     * @throws NamingException if there are any errors propagating the name 
     *        changes.
     * @see org.apache.ldap.server.backend.Database#modifyRdn(javax.naming.Name, 
     * java.lang.String, boolean)
     */
    public void modifyRdn( Name a_dn, String a_newRdn, boolean a_deleteOldRdn )
        throws NamingException
    {
        String l_newRdnAttr = NamespaceTools.getRdnAttribute( a_newRdn ) ;
        String l_newRdnValue = NamespaceTools.getRdnValue( a_newRdn ) ;
        BigInteger l_id = getEntryId( a_dn.toString() ) ;
        Attributes l_entry = lookup( l_id ) ;
        Name l_updn = new LdapName( getEntryUpdn( l_id ) ) ;

        /* 
         * H A N D L E   N E W   R D N
         * ====================================================================
         * Add the new Rdn attribute to the entry.  If an index exists on the 
         * new Rdn attribute we add the index for this attribute value pair.
         * Also we make sure that the existance index shows the existance of the
         * new Rdn attribute within this entry.
         */
        
        l_entry.put( l_newRdnAttr, l_newRdnValue ) ;
        
        if ( hasUserIndexOn( l_newRdnAttr ) )
        {
            Index l_idx = getUserIndex( l_newRdnAttr ) ;
            l_idx.add( l_newRdnValue, l_id ) ;
            
            // Make sure the altered entry shows the existance of the new attrib
            if ( ! m_existanceIdx.hasValue( l_newRdnAttr, l_id ) )
            {
                m_existanceIdx.add( l_newRdnAttr, l_id ) ;
            }
        }

        /*
         * H A N D L E   O L D   R D N
         * ====================================================================
         * If the old Rdn is to be removed we need to get the attribute and 
         * value for it.  Keep in mind the old Rdn need not be based on the 
         * same Rdn as the new one.  We remove the Rdn value from the entry
         * and remove the value/id tuple from the index on the old Rdn attr
         * if any.  We also test if the delete of the old Rdn index tuple 
         * removed all the attribute values of the old Rdn using a reverse
         * lookup.  If so that means we blew away the last value of the old 
         * Rdn attribute.  In this case we need to remove the attrName/id 
         * tuple from the existance index.
         */

        if ( a_deleteOldRdn )
        {
            String l_oldRdn = l_updn.get( l_updn.size() - 1 ) ;
            String l_oldRdnAttr = NamespaceTools.getRdnAttribute( l_oldRdn ) ;
            String l_oldRdnValue = NamespaceTools.getRdnAttribute( l_oldRdn ) ;
            
            l_entry.get( l_oldRdnAttr ).remove( l_oldRdnValue ) ;

            if ( hasUserIndexOn( l_oldRdnAttr ) )
            {
                Index l_idx = getUserIndex( l_oldRdnAttr ) ;
                l_idx.drop( l_oldRdnValue, l_id ) ;
                
                /*
                 * If there is no value for l_id in this index due to our
                 * drop above we remove the l_oldRdnAttr from the existance idx
                 */
                if ( null == l_idx.reverseLookup( l_id ) )
                {
                    m_existanceIdx.drop( l_oldRdnAttr, l_id ) ;
                }
            }
        }
        
        /*
         * H A N D L E   D N   C H A N G E
         * ====================================================================
         * 1) Build the new user defined distinguished name
         *      - clone / copy old updn
         *      - remove old upRdn from copy
         *      - add the new upRdn to the copy
         * 2) Make call to recursive modifyDn method to change the names of the
         *    entry and its descendants
         */

        Name l_newUpdn = ( Name ) l_updn.clone() ;      // copy da old updn
        l_newUpdn.remove( l_newUpdn.size() - 1 ) ;      // remove old upRdn
        l_newUpdn.add( l_newUpdn.size(), a_newRdn ) ;   // add da new upRdn
        modifyDn( l_id, l_newUpdn, false ) ;            // propagate dn changes
    }
    
    
    /*
     * The move operation severs a child from a parent creating a new parent
     * child relationship.  As a consequence the relationships between the 
     * old ancestors of the child and its descendants change.  A descendant is
     *   
     */

    /**
     * Recursively modifies the distinguished name of an entry and the names of
     * its descendants calling itself in the recursion.
     *
     * @param a_id the primary key of the entry
     * @param a_updn User provided distinguished name to set as the new DN
     * @param a_isMove whether or not the name change is due to a move operation
     * which affects alias indices.
     * @throws NamingException if something goes wrong
     */
    private void modifyDn( BigInteger a_id, Name a_updn, boolean a_isMove )
        throws  NamingException
    {
        String l_aliasTarget = null ;

        // Now we can handle the appropriate name indices for all cases
        m_ndnIdx.drop( a_id ) ;
        m_ndnIdx.add( m_ndnIdx.getNormalized( a_updn.toString() ), a_id ) ;
        
        m_updnIdx.drop( a_id ) ;
        m_updnIdx.add( a_updn.toString(), a_id ) ;
        
        /* 
         * Read Alias Index Tuples
         * 
         * If this is a name change due to a move operation then the one and
         * subtree indices for aliases were purged before the aliases were 
         * moved.  Now we must add them for each alias entry we have moved.  
         * 
         * l_aliasTarget is used as a marker to tell us if we're moving an 
         * alias.  If it is null then the moved entry is not an alias.
         */
        if ( a_isMove ) 
        {
            l_aliasTarget = ( String ) m_aliasIdx.reverseLookup( a_id ) ;
    
            if ( null != l_aliasTarget )
            {
                addAliasIndices( a_id, new LdapName( getEntryDn( a_id ) ), 
                    l_aliasTarget ) ;
            }
        }
        
        NamingEnumeration l_children = list( a_id ) ;
        while ( l_children.hasMore() ) 
        {
            // Get the child and its id
            IndexRecord l_rec = ( IndexRecord ) l_children.next() ;
            BigInteger l_childId = l_rec.getEntryId() ;
            
            /* 
             * Calculate the Dn for the child's new name by copying the parents
             * new name and adding the child's old upRdn to new name as its Rdn
             */
            Name l_childUpdn = ( Name ) a_updn.clone() ;
            Name l_oldUpdn = new LdapName( getEntryUpdn( l_childId ) ) ;
            String l_rdn = LdapName.getRdn( l_oldUpdn ) ; 
            l_childUpdn.add( l_childUpdn.size(),  l_rdn ) ;

            // Recursively change the names of the children below
            modifyDn( l_childId, l_childUpdn, a_isMove ) ;
        }
    }


    /**
     * @see org.apache.ldap.server.backend.Database#move(javax.naming.Name, 
     * javax.naming.Name, java.lang.String, boolean)
     */
    public void move( Name a_oldChildDn, Name a_newParentDn, String a_newRdn,
        boolean a_deleteOldRdn ) throws NamingException
    {
        modifyRdn( a_oldChildDn, a_newRdn, a_deleteOldRdn ) ;
        move( a_oldChildDn, a_newParentDn ) ;
    }


    /**
     * Moves an entry under a new parent.  The operation causes a shift in the
     * parent child relationships between the old parent, new parent and the 
     * child moved.  All other descendant entries under the child never change
     * their direct parent child relationships.  Hence after the parent child
     * relationship changes are broken at the old parent and set at the new
     * parent a modifyDn operation is conducted to handle name changes 
     * propagating down through the moved child and its descendants.
     * 
     * @param a_oldChildDn the normalized dn of the child to be moved
     * @param a_newParentDn the normalized dn of the new parent for the child
     * @throws NamingException if something goes wrong
     *
     * @see org.apache.ldap.server.backend.Database#move(javax.naming.Name, 
     * javax.naming.Name)
     */
    public void move( Name a_oldChildDn, Name a_newParentDn ) 
        throws NamingException 
    {
        // Get the child and the new parent to be entries and Ids
        BigInteger l_childId = getEntryId( a_oldChildDn.toString() ) ;
        BigInteger l_newParentId = getEntryId( a_newParentDn.toString() ) ;
        BigInteger l_oldParentId = getParentId( l_childId ) ;
        
        /*
         * All aliases including and below a_oldChildDn, will be affected by
         * the move operation with respect to one and subtree indices since 
         * their relationship to ancestors above a_oldChildDn will be 
         * destroyed.  For each alias below and including a_oldChildDn we will
         * drop the index tuples mapping ancestor ids above a_oldChildDn to the
         * respective target ids of the aliases.
         */
        dropMovedAliasIndices( a_oldChildDn ) ;
        
        /*
         * Drop the old parent child relationship and add the new one
         * Set the new parent id for the child replacing the old parent id
         */
        m_heirarchyIdx.drop( l_oldParentId, l_childId ) ;
        m_heirarchyIdx.add( l_newParentId, l_childId ) ;

        /*
         * Build the new user provided DN (updn) for the child using the child's
         * user provided RDN & the new parent's UPDN.  Basically add the child's
         * UpRdn String to the tail of the new parent's Updn Name.
         */
        Name l_childUpdn = new LdapName( getEntryUpdn( l_childId ) ) ;
        String l_childRdn = l_childUpdn.get( l_childUpdn.size() - 1 ) ; 
        Name l_newUpdn = new LdapName( getEntryUpdn( l_newParentId ) ) ;
        l_newUpdn.add( l_newUpdn.size(), l_childRdn ) ;

        // Call the modifyDn operation with the new updn
        modifyDn( l_childId, l_newUpdn, true ) ;
    }


    /**
     * For all aliases including and under the moved base, this method removes
     * one and subtree alias index tuples for old ancestors above the moved base
     * that will no longer be ancestors after the move.
     * 
     * @param a_movedBase the base at which the move occured - the moved node
     * @throws NamingException if system indices fail
     */
    private void dropMovedAliasIndices( final Name a_movedBase )
        throws NamingException
    {
        // Find all the aliases from a_movedBase down
        IndexAssertion l_isBaseDescendant = new IndexAssertion()
        {
            public boolean assertCandidate( IndexRecord a_rec )
                throws NamingException
            {
                String l_dn = getEntryDn( a_rec.getEntryId() ) ;
                if ( l_dn.endsWith( a_movedBase.toString() ) )
                {
                    return true ;
                }
                
                return false ;
            }
        } ;
        
        BigInteger l_movedBaseId = getEntryId( a_movedBase.toString() ) ;
        if ( m_aliasIdx.reverseLookup( l_movedBaseId ) != null ) 
        {
            dropAliasIndices( l_movedBaseId, a_movedBase ) ;
        }
        
        NamingEnumeration l_aliases = new IndexAssertionEnumeration( 
            m_aliasIdx.listIndices( a_movedBase.toString(), true ), 
            l_isBaseDescendant ) ;
        while ( l_aliases.hasMore() )
        {
            IndexRecord l_entry = ( IndexRecord ) l_aliases.next() ;
            dropAliasIndices( l_entry.getEntryId(), a_movedBase ) ;
        }
    }
    
    
    /**
     * For the alias id all ancestor one and subtree alias tuples are moved 
     * above the moved base.
     * 
     * @param a_aliasId the id of the alias 
     * @param a_movedBase the base where the move occured
     * @throws NamingException if indices fail
     */
    private void dropAliasIndices( BigInteger a_aliasId, Name a_movedBase )
        throws NamingException
    {
        String l_targetDn = ( String ) m_aliasIdx.reverseLookup( a_aliasId ) ;
        BigInteger l_targetId = getEntryId( l_targetDn ) ;
        String l_aliasDn = getEntryDn( a_aliasId ) ;
        
        /*
         * Start droping index tuples with the first ancestor right above the 
         * moved base.  This is the first ancestor effected by the move.
         */
        Name l_ancestorDn = a_movedBase.getSuffix( 1 ) ;
        BigInteger l_ancestorId = getEntryId( l_ancestorDn.toString() ) ;
        
        /*
         * We cannot just drop all tuples in the one level and subtree indices
         * linking baseIds to the l_targetId.  If more than one alias refers to
         * the target then droping all tuples with a value of targetId would
         * make all other aliases to the target inconsistent.
         * 
         * We need to walk up the path of alias ancestors right above the moved 
         * base until we reach the suffix, deleting each ( l_ancestorId, 
         * l_targetId ) tuple in the subtree scope alias.  We only need to do 
         * this for the direct parent of the alias on the one level subtree if
         * the moved base is the alias.
         */
        if ( l_aliasDn.equals( a_movedBase.toString() ) )
        {
            m_oneAliasIdx.drop( l_ancestorId, l_targetId ) ;
        }
        
        m_subAliasIdx.drop( l_ancestorId, l_targetId ) ;
        
        while ( ! l_ancestorDn.equals( m_suffix ) )
        {
            l_ancestorDn = l_ancestorDn.getSuffix( 1 ) ;
            l_ancestorId = getEntryId( l_ancestorDn.toString() ) ;
            
            m_subAliasIdx.drop( l_ancestorId, l_targetId ) ;
        }    
    }
}

