<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<article lang="en-US">









































































<sect1><title>Operational Attributes</title><sect2><title>Operational Attributes</title>
<para/>
<para>Backends may need to add implementation specific operational attributes to entries. 
An example of such an attribute is the entryId attribute used by the DefualtBackend. 
It stores the backend unique primary key for the entry. 
The entryId attribute only has meaning within the DefaultBackend implementation.</para>
<para/>
<para>The DefaultBackend currently has two critical system indices: the name index and the heirarchy index. 
The forward table of the name index maps normalized distinguished names to primary keys and the reverse table maps in the opposite direction. 
All indices in this way are bidirectional<footnote>
<para>From now on when referring to an index we will refer to the forward mapping however keep in mind indices are bidirectional.</para>

</footnote>
. 
The heirarchy index maps parent entry primary keys to their children and vice versa. 
These two indices allow for naming and heirarchy within the DefaultBackend and are absolutely necessary. 
The existance index is a non-critical system index which maps attribute names to primary keys. 
The index helps quickly answer questions regarding whether or not an entry contains an attribute or provides a quick listing of entries containing a particular attribute.</para>
<para/>
<para>The DefaultBackend currently stores the primary key of an entry within the entry as an attribute with the name 'entryId'. 
This implementation specific operational attribute brands the Attributes object with its database specific primary key. 
The Backend interface or its subclasses never uses this primary key because the key is an implementation specific operational attribute. 
Logically the distinguished name is the primary key. 
The DefaultBackend uses the BigInteger based primary key to avoid the unnecessary replication and normalization of Dn Strings within indices. 
The use of such a integer based primary key reduces space consumption and increases speed.</para>
<para/>
<para>Is it really necessary to store the primary key of an entry within the entry? In the past, entries leaving a backend could make their way back into it. 
The design of older Backend interfaces allowed this. 
Hence any entry leaving the Backend had to be branded with its primary key this way using the entryId operational attribute. 
Now we need to reconsider this with the new Backend interface design. 
These previous situations no longer exist for Attributes and storage of such an operational attribute need not be required. 
Other operational attributes like the parentId need not be stored with the entry either. 
These attributes can be derived from system indices. 
At first glance it might make sense to store these values so extra lookups against a system index are not required. 
The lookups however against system indices are not as costly as one would expect. 
The index caches both keys and values at two layers. 
First the index tracks the normalizations that have occurred on its keys. 
Secondly each of its tables keeps a MRU cache on the records of each forward and reverse B+Tree. 
Rather than load, store and cache these values within the entry Attributes we could load, store and cache them within an index. 
Hence the storage of the parentId within the entry Attributes as and operational attribute is unnecessary â€“ there really is no value add.</para>
<para/>
<para>The entryId can be argued to have value as an operational attribute when operations are performed internally on a set of entries. 
For example it might be nice to have an immediate handle on the primary key so the parentId and other attributes can be immediately looked up. 
This also is a false sense to have. 
All the methods of backends and database internal classes are designed to propagate the normalized distinguished name of the entry along with its Attributes if necessary. 
The normalized Dn is a unique key that can immediately return the entry's primary key and most of the time it will be cached by the name system index. 
Hence it is also unnecessary to store the entryId as an operational attribute within the entry's Attributes.</para>
<para/>
<para>Another operational attribute is the user provided distinguished name of an entry. 
It is currently stored within an entry's Attributes as a Attribute. 
Is this attribute necessary? 
The answer depends on whether or not this information can be extracted from a system index. 
Right now the answer is no so the attribute would need to be kept within the entry's Attributes as an operational Attribute. 
However if there was a normalized dn to user provided dn index or a primary key to user provided index then this information can be extracted when needed. 
So two questions now arise:</para>
<orderedlist>
<listitem>
<orderedlist>
<listitem>
<para>Do we continue to store the user provided Dn within the entry's Attributes or do we maintain a critical system index for user provided distinguished names?</para>
</listitem>
<listitem>
<para>If we are to maintain an index instead of storing the operational attribute within the entry then how should the index map the user provided distinguished name? Should we map the primary key to the updn or should we map normalized names to the updn?</para>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<para>The answer to the first question really boils down to a matter of consistancy. 
There really seems to be no direct advantage to one means or another. 
However seeing how other operational attributes are already maintained within indices it might be better to store these values within an index for the sake of consistancy. 
The second question also boils down to consistancy as well. 
Up until now the purpose of a numeric primary key was to reduce the amount of string replication within indices by using the BigInteger based primary key instead. 
Falling in line with this same motif, we should be consistant by maping the user provided distinguished name to the primary key id of the entry. 
The reverse table can be used to immediately lookup the updn for an entry by its primary key. 
So there will be two critical system name indices: the normalized Dn (ndn) index and the user provided 
Dn (updn) index.</para>
<para/>
<para>A very special critical system index that will be required is the alias index maping alias entry primary keys to target entry primary keys. 
Discussion of this index will be left until we cover the aspects of search with aliases.</para>
<para/>
<para>After refactoring the changes to remove the use of implemenation specific operational attributes we discovered great performance advantages for the modifyRdn and move operations on a backend. 
Because operational attributes are not used the entry's Attributes do not need to be looked up and stored for a name change or a move to a new parent. 
All changes occur on system indices rather than on operational attributes. 
This makes move and Dn/Rdn changes very fast.</para>
<para/></sect2></sect1>
</article>
