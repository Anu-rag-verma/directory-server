/*
 *                                 Apache License
 *                           Version 2.0, January 2004
 *                        http://www.apache.org/licenses/
 *
 *   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 *   1. Definitions.
 *
 *      "License" shall mean the terms and conditions for use, reproduction,
 *      and distribution as defined by Sections 1 through 9 of this document.
 *
 *      "Licensor" shall mean the copyright owner or entity authorized by
 *      the copyright owner that is granting the License.
 *
 *      "Legal Entity" shall mean the union of the acting entity and all
 *      other entities that control, are controlled by, or are under common
 *      control with that entity. For the purposes of this definition,
 *      "control" means (i) the power, direct or indirect, to cause the
 *      direction or management of such entity, whether by contract or
 *      otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *      outstanding shares, or (iii) beneficial ownership of such entity.
 *
 *      "You" (or "Your") shall mean an individual or Legal Entity
 *      exercising permissions granted by this License.
 *
 *      "Source" form shall mean the preferred form for making modifications,
 *      including but not limited to software source code, documentation
 *      source, and configuration files.
 *
 *      "Object" form shall mean any form resulting from mechanical
 *      transformation or translation of a Source form, including but
 *      not limited to compiled object code, generated documentation,
 *      and conversions to other media types.
 *
 *      "Work" shall mean the work of authorship, whether in Source or
 *      Object form, made available under the License, as indicated by a
 *      copyright notice that is included in or attached to the work
 *      (an example is provided in the Appendix below).
 *
 *      "Derivative Works" shall mean any work, whether in Source or Object
 *      form, that is based on (or derived from) the Work and for which the
 *      editorial revisions, annotations, elaborations, or other modifications
 *      represent, as a whole, an original work of authorship. For the purposes
 *      of this License, Derivative Works shall not include works that remain
 *      separable from, or merely link (or bind by name) to the interfaces of,
 *      the Work and Derivative Works thereof.
 *
 *      "Contribution" shall mean any work of authorship, including
 *      the original version of the Work and any modifications or additions
 *      to that Work or Derivative Works thereof, that is intentionally
 *      submitted to Licensor for inclusion in the Work by the copyright owner
 *      or by an individual or Legal Entity authorized to submit on behalf of
 *      the copyright owner. For the purposes of this definition, "submitted"
 *      means any form of electronic, verbal, or written communication sent
 *      to the Licensor or its representatives, including but not limited to
 *      communication on electronic mailing lists, source code control systems,
 *      and issue tracking systems that are managed by, or on behalf of, the
 *      Licensor for the purpose of discussing and improving the Work, but
 *      excluding communication that is conspicuously marked or otherwise
 *      designated in writing by the copyright owner as "Not a Contribution."
 *
 *      "Contributor" shall mean Licensor and any individual or Legal Entity
 *      on behalf of whom a Contribution has been received by Licensor and
 *      subsequently incorporated within the Work.
 *
 *   2. Grant of Copyright License. Subject to the terms and conditions of
 *      this License, each Contributor hereby grants to You a perpetual,
 *      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *      copyright license to reproduce, prepare Derivative Works of,
 *      publicly display, publicly perform, sublicense, and distribute the
 *      Work and such Derivative Works in Source or Object form.
 *
 *   3. Grant of Patent License. Subject to the terms and conditions of
 *      this License, each Contributor hereby grants to You a perpetual,
 *      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *      (except as stated in this section) patent license to make, have made,
 *      use, offer to sell, sell, import, and otherwise transfer the Work,
 *      where such license applies only to those patent claims licensable
 *      by such Contributor that are necessarily infringed by their
 *      Contribution(s) alone or by combination of their Contribution(s)
 *      with the Work to which such Contribution(s) was submitted. If You
 *      institute patent litigation against any entity (including a
 *      cross-claim or counterclaim in a lawsuit) alleging that the Work
 *      or a Contribution incorporated within the Work constitutes direct
 *      or contributory patent infringement, then any patent licenses
 *      granted to You under this License for that Work shall terminate
 *      as of the date such litigation is filed.
 *
 *   4. Redistribution. You may reproduce and distribute copies of the
 *      Work or Derivative Works thereof in any medium, with or without
 *      modifications, and in Source or Object form, provided that You
 *      meet the following conditions:
 *
 *      (a) You must give any other recipients of the Work or
 *          Derivative Works a copy of this License; and
 *
 *      (b) You must cause any modified files to carry prominent notices
 *          stating that You changed the files; and
 *
 *      (c) You must retain, in the Source form of any Derivative Works
 *          that You distribute, all copyright, patent, trademark, and
 *          attribution notices from the Source form of the Work,
 *          excluding those notices that do not pertain to any part of
 *          the Derivative Works; and
 *
 *      (d) If the Work includes a "NOTICE" text file as part of its
 *          distribution, then any Derivative Works that You distribute must
 *          include a readable copy of the attribution notices contained
 *          within such NOTICE file, excluding those notices that do not
 *          pertain to any part of the Derivative Works, in at least one
 *          of the following places: within a NOTICE text file distributed
 *          as part of the Derivative Works; within the Source form or
 *          documentation, if provided along with the Derivative Works; or,
 *          within a display generated by the Derivative Works, if and
 *          wherever such third-party notices normally appear. The contents
 *          of the NOTICE file are for informational purposes only and
 *          do not modify the License. You may add Your own attribution
 *          notices within Derivative Works that You distribute, alongside
 *          or as an addendum to the NOTICE text from the Work, provided
 *          that such additional attribution notices cannot be construed
 *          as modifying the License.
 *
 *      You may add Your own copyright statement to Your modifications and
 *      may provide additional or different license terms and conditions
 *      for use, reproduction, or distribution of Your modifications, or
 *      for any such Derivative Works as a whole, provided Your use,
 *      reproduction, and distribution of the Work otherwise complies with
 *      the conditions stated in this License.
 *
 *   5. Submission of Contributions. Unless You explicitly state otherwise,
 *      any Contribution intentionally submitted for inclusion in the Work
 *      by You to the Licensor shall be under the terms and conditions of
 *      this License, without any additional terms or conditions.
 *      Notwithstanding the above, nothing herein shall supersede or modify
 *      the terms of any separate license agreement you may have executed
 *      with Licensor regarding such Contributions.
 *
 *   6. Trademarks. This License does not grant permission to use the trade
 *      names, trademarks, service marks, or product names of the Licensor,
 *      except as required for reasonable and customary use in describing the
 *      origin of the Work and reproducing the content of the NOTICE file.
 *
 *   7. Disclaimer of Warranty. Unless required by applicable law or
 *      agreed to in writing, Licensor provides the Work (and each
 *      Contributor provides its Contributions) on an "AS IS" BASIS,
 *      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *      implied, including, without limitation, any warranties or conditions
 *      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *      PARTICULAR PURPOSE. You are solely responsible for determining the
 *      appropriateness of using or redistributing the Work and assume any
 *      risks associated with Your exercise of permissions under this License.
 *
 *   8. Limitation of Liability. In no event and under no legal theory,
 *      whether in tort (including negligence), contract, or otherwise,
 *      unless required by applicable law (such as deliberate and grossly
 *      negligent acts) or agreed to in writing, shall any Contributor be
 *      liable to You for damages, including any direct, indirect, special,
 *      incidental, or consequential damages of any character arising as a
 *      result of this License or out of the use or inability to use the
 *      Work (including but not limited to damages for loss of goodwill,
 *      work stoppage, computer failure or malfunction, or any and all
 *      other commercial damages or losses), even if such Contributor
 *      has been advised of the possibility of such damages.
 *
 *   9. Accepting Warranty or Additional Liability. While redistributing
 *      the Work or Derivative Works thereof, You may choose to offer,
 *      and charge a fee for, acceptance of support, warranty, indemnity,
 *      or other liability obligations and/or rights consistent with this
 *      License. However, in accepting such obligations, You may act only
 *      on Your own behalf and on Your sole responsibility, not on behalf
 *      of any other Contributor, and only if You agree to indemnify,
 *      defend, and hold each Contributor harmless for any liability
 *      incurred by, or claims asserted against, such Contributor by reason
 *      of your accepting any such warranty or additional liability.
 *
 *   END OF TERMS AND CONDITIONS
 *
 *   APPENDIX: How to apply the Apache License to your work.
 *
 *      To apply the Apache License to your work, attach the following
 *      boilerplate notice, with the fields enclosed by brackets "[]"
 *      replaced with your own identifying information. (Don't include
 *      the brackets!)  The text should be enclosed in the appropriate
 *      comment syntax for the file format. We also recommend that a
 *      file or class name and description of purpose be included on the
 *      same "printed page" as the copyright notice for easier
 *      identification within third-party archives.
 *
 *   Copyright [yyyy] [name of copyright owner]
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

/*
 * $Id: BackendFrame.java,v 1.10 2003/10/13 18:09:18 akarasulu Exp $
 *
 * -- (c) LDAPd Group                                                    --
 * -- Please refer to the LICENSE.txt file in the root directory of      --
 * -- any LDAPd project for copyright and distribution information.      --
 *
 */

package org.apache.ldap.server.backend.db.gui ;


import java.io.File ;
import java.io.FileReader ;
import java.io.IOException ;
import java.io.FileNotFoundException ;

import java.math.BigInteger ;
import java.text.ParseException ;

import java.util.Stack ;
import java.util.HashMap ;
import java.util.Iterator ;
import java.util.Hashtable ;

import java.awt.Window ;
import java.awt.Toolkit ;
import java.awt.Dimension ;
import java.awt.BorderLayout ;
import java.awt.event.ActionEvent ;
import java.awt.event.ActionListener ;

import javax.naming.NamingException ;
import javax.naming.NamingEnumeration ; 
import javax.naming.directory.Attributes ;
import javax.naming.directory.SearchControls ;

import javax.swing.JTree ;
import javax.swing.JMenu ;
import javax.swing.JTable ;
import javax.swing.JFrame ;
import javax.swing.JPanel ;
import javax.swing.JLabel ;
import javax.swing.JMenuBar ;
import javax.swing.JMenuItem ;
import javax.swing.JTextArea ;
import javax.swing.JSplitPane ;
import javax.swing.JSeparator ;
import javax.swing.JScrollPane ;
import javax.swing.JTabbedPane ;
import javax.swing.JOptionPane ;
import javax.swing.JFileChooser ;
import javax.swing.tree.TreePath ;
import javax.swing.tree.TreeNode ;
import javax.swing.tree.TreeModel ;
import javax.swing.tree.DefaultTreeModel ;
import javax.swing.tree.TreeSelectionModel ;
import javax.swing.table.DefaultTableModel ;
import javax.swing.event.TreeSelectionEvent ;
import javax.swing.event.TreeSelectionListener ;

import org.apache.ldap.common.name.LdapName ;
import org.apache.ldap.common.ldif.LdifParser ;
import org.apache.ldap.common.filter.ExprNode ;
import org.apache.ldap.common.util.StringTools ;
import org.apache.ldap.common.ldif.LdifIterator ;
import org.apache.ldap.common.ldif.LdifParserImpl ;
import org.apache.ldap.server.backend.db.Database ;
import org.apache.ldap.common.filter.FilterParser ;
import org.apache.ldap.server.backend.db.index.Index ;
import org.apache.ldap.server.backend.AbstractBackend ;
import org.apache.ldap.common.filter.FilterParserImpl ;
import org.apache.ldap.common.message.DerefAliasesEnum ;
import org.apache.ldap.server.backend.db.index.IndexRecord ;
import org.apache.ldap.common.message.LockableAttributesImpl ;

import org.apache.avalon.framework.logger.Logger ;
import org.apache.avalon.framework.logger.LogEnabled ;


/**
 * @todo Document me!
 * 
 * @author <a href="mailto:aok123@bellsouth.net">Alex Karasulu</a>
 * @author $Author: akarasulu $
 * @version $Revision: 1.10 $
 */
public class BackendFrame
    extends JFrame
    implements LogEnabled
{
    // Swing Stuff
    private BorderLayout m_layout = new BorderLayout() ;
    private JLabel m_statusBar = new JLabel( "Ready" ) ;
    private JPanel m_mainPnl = new JPanel() ;
    private JSplitPane m_splitPane = new JSplitPane() ;
    private JTabbedPane m_tabbedPane = new JTabbedPane() ;
    private JPanel m_entryPnl = new JPanel() ;
    private JPanel m_idxPnl = new JPanel() ;
    private JScrollPane m_treePane = new JScrollPane() ;
    private JTree m_tree = new JTree() ;
    private JScrollPane m_entryPane = new JScrollPane() ;
    private JTable m_entryTbl = new JTable() ;
    private JScrollPane m_idxPane = new JScrollPane() ;
    private JTable m_idxTbl = new JTable() ;
    private JMenu m_searchMenu = new JMenu() ;
    private JMenuItem m_annotate = new JMenuItem() ;
    private JMenuItem m_run = new JMenuItem() ;
    private JMenuItem m_debug = new JMenuItem() ;
    private JMenu m_indices = new JMenu() ;

    // Non Swing Stuff
    private Database m_database = null ;
    private AbstractBackend m_backend = null ;
    private boolean m_doCleanUp = false ;
    private HashMap m_nodes = new HashMap() ;
    private EntryNode m_root = null ;
    private Logger m_logger = null ;


    /**
     * Creates new form JFrame
     */
    public BackendFrame( AbstractBackend a_backend, Logger a_logger ) 
        throws Exception
    {
        m_backend = a_backend ;
        m_database = m_backend.getDb() ;
        m_logger = a_logger ;
        
        initGUI() ;
        buildIndicesMenu( m_database ) ;
        pack() ;
        load() ;
    }


    /**
     * This method is called from within the constructor to initialize the form
     */
    private void initGUI() 
    {
        m_mainPnl.setBorder( null ) ;
        m_mainPnl.setLayout( new java.awt.BorderLayout() ) ;
        m_mainPnl.add( m_splitPane, java.awt.BorderLayout.CENTER ) ;
        m_splitPane.add( m_tabbedPane, javax.swing.JSplitPane.RIGHT ) ;
        m_splitPane.add( m_treePane, javax.swing.JSplitPane.LEFT ) ;
        m_tabbedPane.add( m_entryPnl, "Entry Attributes" ) ;
        m_tabbedPane.add( m_idxPnl, "Entry Indices" ) ;

        m_entryPnl.setLayout( new java.awt.BorderLayout() ) ;
        m_entryPnl.add( m_entryPane, java.awt.BorderLayout.CENTER ) ;

        m_idxPnl.setLayout( new java.awt.BorderLayout() ) ;
        m_idxPnl.add( m_idxPane, java.awt.BorderLayout.CENTER ) ;

        getContentPane().setLayout( new java.awt.BorderLayout() ) ;
        JPanel l_content = new JPanel() ;
        l_content.setPreferredSize( new java.awt.Dimension( 798, 461 ) ) ;
        l_content.setLayout( new java.awt.BorderLayout() ) ;
        l_content.setBorder( javax.swing.BorderFactory.createEtchedBorder() ) ;
        l_content.add( m_mainPnl, java.awt.BorderLayout.NORTH ) ;
        getContentPane().add( l_content, BorderLayout.CENTER ) ;
        // set title
        setTitle( "Backend DB Viewer" ) ;
        // add status bar
        getContentPane().add( m_statusBar, BorderLayout.SOUTH ) ;
        // add menu bar
        JMenuBar l_menuBar = new JMenuBar() ;

        // --------------------------------------------------------------------
        // 'Backend' Menu
        // --------------------------------------------------------------------
        
        JMenu l_backendMenu = new JMenu( "Backend" ) ;
        l_backendMenu.setText( "Backend" ) ;
        l_backendMenu.setBackground( new java.awt.Color( 205, 205, 205 ) ) ;
        l_backendMenu.setMnemonic( 'B' ) ;

        // create Import menu item
        JMenuItem l_add = new JMenuItem( "Add" ) ;
        l_backendMenu.add( l_add ) ;
        l_add.setMnemonic( 'A' ) ;
        l_add.setBackground( new java.awt.Color( 205, 205, 205 ) ) ;
        l_add.addActionListener( new ActionListener() 
        {
            public void actionPerformed( ActionEvent e ) 
            {
                doAddDialog() ;
            }
        } ) ;

        // create Import menu item
        JMenuItem l_import = new JMenuItem( "Import" ) ;
        l_backendMenu.add( l_import ) ;
        l_import.setMnemonic( 'I' ) ;
        l_import.setBackground( new java.awt.Color( 205, 205, 205 ) ) ;
        l_import.addActionListener( new ActionListener() 
        {
            public void actionPerformed( ActionEvent e ) 
            {
                doImport() ;
            }
        } ) ;

        // create Exit menu item
        JMenuItem l_exit = new JMenuItem( "Exit" ) ;
        l_backendMenu.add( l_exit ) ;
        l_exit.setMnemonic( 'E' ) ;
        l_exit.setBackground( new java.awt.Color( 205, 205, 205 ) ) ;
        l_exit.addActionListener( new ActionListener() 
        {
            public void actionPerformed( ActionEvent e ) 
            {
                exitForm() ;
            }
        } ) ;

        // create About menu item
        JMenu m_helpMenu = new JMenu( "Help" ) ;
        m_helpMenu.setMnemonic( 'H' ) ;
        JMenuItem m_about = new JMenuItem( "About" ) ;
        m_about.setMnemonic( 'A' ) ;
        m_about.setBackground( new java.awt.Color( 205,205,205 ) ) ;
        m_about.addActionListener( new ActionListener() 
        {
            public void actionPerformed( ActionEvent e ) 
            {
                AboutDialog aboutDialog = 
                    new AboutDialog ( BackendFrame.this, true ) ;
                BackendFrame.this.centerOnScreen( aboutDialog ) ;
                aboutDialog.setVisible( true ) ;
            }
        } ) ;
        m_helpMenu.setBackground( new java.awt.Color( 205,205,205 ) ) ;
        m_helpMenu.add( m_about ) ;
        
        // create Save menu item
        // create Print menu item
        l_menuBar.setBackground( new java.awt.Color( 196,197,203 ) ) ;
        l_menuBar.add( l_backendMenu ) ;
        l_menuBar.add( m_searchMenu ) ;
        l_menuBar.add( m_indices ) ;
        l_menuBar.add( m_helpMenu ) ;
        // sets menu bar
        setJMenuBar( l_menuBar ) ;
        setBounds( new java.awt.Rectangle( 0, 0, 802, 515 ) ) ;
        setSize( new java.awt.Dimension( 802,515 ) ) ;
        setResizable( true ) ;
        
        addWindowListener( new java.awt.event.WindowAdapter() 
        {
            public void windowClosing( java.awt.event.WindowEvent evt ) 
            {
                exitForm() ;
            }
        } ) ;
        
        m_treePane.getViewport().add( m_tree ) ;
        m_tree.setBounds( new java.awt.Rectangle( 6,184,82,80 ) ) ;
        m_tree.setShowsRootHandles( true ) ;
        m_tree.setToolTipText( "DB DIT" ) ;
        m_tree.setScrollsOnExpand( true ) ;
        m_tree.getSelectionModel().addTreeSelectionListener(
            new TreeSelectionListener() 
        {
            public void valueChanged( TreeSelectionEvent e ) 
            {
                TreePath l_path = e.getNewLeadSelectionPath() ;
                TreeSelectionModel l_model = 
                    ( TreeSelectionModel ) e.getSource() ;

                if ( l_path == null ) 
                {
                    return ;
                }

                Object l_last = l_path.getLastPathComponent() ;
                try 
                {
                    if ( l_last instanceof EntryNode ) 
                    {
                        displayEntry( ( ( EntryNode ) l_last ).getEntryId(), 
                        ( ( EntryNode ) l_last).getLdapEntry() ) ;
                    }
                } 
                catch( Exception ex ) 
                {
                    ex.printStackTrace() ;
                }
            }
        } ) ;

        m_entryPane.getViewport().add( m_entryTbl ) ;
        m_entryTbl.setBounds( new java.awt.Rectangle( 321,103,32,32 ) ) ;

        m_idxPane.getViewport().add( m_idxTbl ) ;
        m_idxTbl.setBounds( new java.awt.Rectangle( 429,134,32,32 ) ) ;

        m_treePane.setSize( new java.awt.Dimension( 285, 435 ) ) ;
        m_treePane.setPreferredSize( new java.awt.Dimension( 285, 403 ) ) ;
        m_searchMenu.setText( "Search" ) ;
        m_searchMenu.setBackground( new java.awt.Color( 205,205,205 ) ) ;
        m_searchMenu.add( m_run ) ;
        m_searchMenu.add( m_debug ) ;
        m_searchMenu.add( m_annotate ) ;

        ActionListener l_searchHandler = new ActionListener()
        {
            public void actionPerformed( ActionEvent an_event ) 
            {
                System.out.println( "action command = " 
                    + an_event.getActionCommand() ) ;
				doFilterDialog( an_event.getActionCommand() ) ;
            }
        } ;

        m_annotate.setText( FilterDialog.ANNOTATE_MODE ) ;
        m_annotate.setActionCommand( FilterDialog.ANNOTATE_MODE ) ;
        m_annotate.setBackground( new java.awt.Color( 205,205,205 ) ) ;
        m_annotate.addActionListener( l_searchHandler ) ;

        m_run.setText( FilterDialog.RUN_MODE ) ;
        m_run.setActionCommand( FilterDialog.RUN_MODE ) ;
        m_run.setBackground( new java.awt.Color( 205,205,205 ) ) ;
        m_run.addActionListener( l_searchHandler ) ;

        m_debug.setText( FilterDialog.DEBUG_MODE ) ;
        m_debug.setActionCommand( FilterDialog.DEBUG_MODE ) ;
        m_debug.setBackground( new java.awt.Color( 205,205,205 ) ) ;
        m_debug.addActionListener( l_searchHandler ) ;

        m_indices.setText( "Indices" ) ;
        m_indices.setBackground( new java.awt.Color( 205, 205, 205 ) ) ;
    }


    public void enableLogging( Logger a_logger )
    {
        m_logger = a_logger ;
    }


    private void centerOnScreen( Window a_window )
    {
        Dimension l_frameSize = a_window.getSize() ;
        Dimension l_screenSize = Toolkit.getDefaultToolkit().getScreenSize() ;
        
        l_frameSize.height = ( ( l_frameSize.height > l_screenSize.height )
            ? l_screenSize.height : l_frameSize.height ) ;
        l_frameSize.width = ( ( l_frameSize.width > l_screenSize.width )
            ? l_screenSize.width : l_frameSize.width ) ;
        a_window.setLocation( ( l_screenSize.width - l_frameSize.width ) / 2,
            ( l_screenSize.height - l_frameSize.height ) / 2 ) ;
    }

    
    /**
     * Displays a entry addition dialog.
     */
    public void doAddDialog()
    {
        try 
        {
            Attributes l_entry = null ;
            TreePath l_path = m_tree.getSelectionModel().getSelectionPath() ;
            String l_parentDn = m_database.getSuffix().toString() ;

            if ( null != l_path ) 
            {
                Object l_last = l_path.getLastPathComponent() ;

                if( l_last instanceof EntryNode ) 
                {
                    l_parentDn = ( ( EntryNode ) l_last ).getEntryDn() ;
                } 
            }
            
            if ( null == l_parentDn )
            {
                JOptionPane.showMessageDialog( this, 
                    "Must select a parent entry to add a child to!" ) ;
                return ;
            }
        
            AddEntryDialog l_dialog = new AddEntryDialog( this, false ) ;
            l_dialog.setParentDn( l_parentDn ) ;
            
            centerOnScreen( l_dialog ) ;
            l_dialog.setEnabled( true ) ;
            l_dialog.setVisible( true ) ;
        }
        catch ( Exception e )
        {
            e.printStackTrace() ;
        }
    }
    

    /**
     * Gets the DN of the DIT node selected in the tree view.
     * 
     * @return the DN of the selected tree node or the root Dn of the tree if 
     * nothing has been selected yet.
     */
    public String getSelectedDn()
    {
        TreePath l_path = m_tree.getSelectionModel().getSelectionPath() ;
        
        if ( null == l_path )
        {
            return m_database.getSuffix().toString() ;
        }        
        
        Object l_last = l_path.getLastPathComponent() ;
        String l_base = null ;
        
        if( l_last instanceof EntryNode ) 
        {
            Attributes l_entry = ( ( EntryNode ) l_last ).getLdapEntry() ;
                
            try
            {
                l_base = ( ( EntryNode ) l_last ).getEntryDn() ;
            }
            catch ( NamingException e )
            {
                e.printStackTrace() ;
            }
        } 
        else 
        {
            l_base = m_database.getSuffix().toString() ;
        }
        
        return l_base ;
    }
    

    public void doImport()
    {
        FileReader l_in = null ;
        LdifIterator l_list = null ;
        LdifParser l_parser = new LdifParserImpl() ;
        JFileChooser l_chooser = new JFileChooser() ;
        int l_choice = l_chooser.showOpenDialog( this ) ;
        File l_selected = l_chooser.getSelectedFile() ;
        
        if ( JFileChooser.APPROVE_OPTION != l_choice )
        {
            return ;
        }

        try 
        {
            l_in = new FileReader( l_selected ) ;
            l_list = new LdifIterator( l_in ) ;
            
            while ( l_list.hasNext() )
            {
                String l_dif = ( String ) l_list.next() ;
                LockableAttributesImpl l_attrs = new LockableAttributesImpl() ;
                l_parser.parse( l_attrs, l_dif ) ;
                String l_updn = ( String ) l_attrs.get( "dn" ).get() ;
                LdapName l_ndn =
                    new LdapName( StringTools.deepTrimToLower( l_updn ) ) ;
                l_attrs.remove( "dn" ) ;

                if ( null == m_database.getEntryId( l_ndn.toString() ) )
                {
                    m_database.add( l_updn, l_ndn, l_attrs ) ;
                    m_logger.debug( "Added entry: " + l_updn ) ;
                    
                    load() ;
                }
                else
                {
                    m_logger.debug( "Passed entry: " + l_updn ) ;
                }                
            }
        }
        catch( ParseException e )
        {
            // @todo display popup with error here!
            e.printStackTrace() ;
            return ;
        } 
        catch( NamingException e )
        {
            // @todo display popup with error here!
            e.printStackTrace() ;
            return ;
        } 
        catch( FileNotFoundException e ) 
        {
            // @todo display popup with error here!
            e.printStackTrace() ;
            return ;
        }
        catch( IOException e ) 
        {
            // @todo display popup with error here!
            e.printStackTrace() ;
            return ;
        }
        catch( Exception e ) 
        {
            // @todo display popup with error here!
            e.printStackTrace() ;
            return ;
        }
    }


    /**
     * Exit the Application
     */
    private void exitForm() 
    {
        setEnabled( false ) ;
        setVisible( false ) ;
        dispose() ;

        if ( m_doCleanUp && m_database != null ) 
        {
            try
            {
                m_database.sync() ;
                m_database.close() ;
            }
            catch ( NamingException e )
            {
                e.printStackTrace() ;
            }

	        System.exit( 0 ) ;
        }
    }
    
    
    public void doRunDebugAnnotate( FilterDialog a_dialog, String a_mode )
    {
        try 
        {
            if ( a_mode == FilterDialog.RUN_MODE ) 
            {
                doRun( a_dialog.getFilter(), a_dialog.getScope(),
                    a_dialog.getBase(), a_dialog.getLimit() ) ;
            } 
            else if ( a_mode == FilterDialog.DEBUG_MODE ) 
            {
                doDebug( a_dialog.getFilter(), a_dialog.getScope(),
                     a_dialog.getBase(), a_dialog.getLimit() ) ;
            } 
            else if ( a_mode == FilterDialog.ANNOTATE_MODE ) 
            {
                if ( doAnnotate( a_dialog.getFilter() ) ) 
                {
                    // continue
                } 
                else 
                {
                    // We failed don't loose users filter buf
                    // allow user to make edits.
                    return ;
                }
            } 
            else 
            {
                throw new RuntimeException( "Unrecognized mode." ) ;
            }
        }
        catch ( Exception e )
        {
            // @todo show error popup here!
            e.printStackTrace() ;
        }
    }


    public void doFilterDialog( final String a_mode )
    {
        final FilterDialog l_dialog = new FilterDialog( a_mode, this, true ) ;

        if ( m_tree.getSelectionModel().getSelectionPath() != null ) 
        {
            l_dialog.setBase( getSelectedDn() ) ;
        } 
        else 
        {
            l_dialog.setBase( m_database.getSuffix().toString() ) ;
        }

        l_dialog.addActionListener( new ActionListener() 
        {
            public void actionPerformed( ActionEvent an_event ) 
            {
                String l_cmd = an_event.getActionCommand() ;

                if ( l_cmd.equals( FilterDialog.SEARCH_CMD ) ) 
                {
                    doRunDebugAnnotate( l_dialog, a_mode ) ;
                } 
                else if ( l_cmd.equals(FilterDialog.CANCEL_CMD ) ) 
                {
                    // Do nothing! Just exit dialog.
                } 
                else 
                {
                    throw new RuntimeException( 
                        "Unrecognized FilterDialog command: " + l_cmd ) ;
                }

				l_dialog.setVisible( false ) ;
				l_dialog.dispose() ;
            }
        } ) ;

        //Center the frame on screen
        l_dialog.setSize( 456, 256 ) ;
        centerOnScreen( l_dialog ) ;
        l_dialog.setEnabled( true ) ;
        l_dialog.setVisible( true ) ;
    } 


    public boolean doRun( String a_filter, String a_scope, String a_base,
        String a_limit )
        throws Exception
    {
        System.out.println( "Search attempt using filter '" + a_filter + "' "
            + "with scope '" + a_scope + "' and a return limit of '" + a_limit
            + "'" ) ;
        FilterParser l_parser = new FilterParserImpl() ;
        l_parser.enableLogging( m_logger ) ;
        ExprNode l_root = null ;

        try 
        {
            l_root = l_parser.parse( a_filter ) ;
        } 
        catch ( Exception e ) 
        {
            e.printStackTrace() ;
            JTextArea l_text = new JTextArea() ;
            String l_msg = e.getMessage() ;

            if ( l_msg.length() > 1024 ) 
            {
                l_msg = l_msg.substring( 0, 1024 ) + "\n. . . truncated . . ." ;
            }

            l_text.setText( l_msg ) ;
            l_text.setEnabled( false ) ;
            JOptionPane.showMessageDialog( null, l_text, "Syntax Error",
                JOptionPane.ERROR_MESSAGE ) ;
            return false ;
        }

        SearchControls l_ctls = new SearchControls() ;

        if ( a_scope == FilterDialog.BASE_SCOPE ) 
        {
	        l_ctls.setSearchScope( SearchControls.OBJECT_SCOPE ) ;
        } 
        else if ( a_scope == FilterDialog.SINGLE_SCOPE ) 
        {
            l_ctls.setSearchScope( SearchControls.ONELEVEL_SCOPE ) ;
        } 
        else if ( a_scope == FilterDialog.SUBTREE_SCOPE ) 
        {
            l_ctls.setSearchScope( SearchControls.SUBTREE_SCOPE ) ;
        } else {
            throw new RuntimeException( "Unexpected scope parameter: " +
                a_scope ) ;
        }

        int l_limit = Integer.MAX_VALUE ;
        if ( ! a_limit.equals( FilterDialog.UNLIMITED ) ) 
        {
            l_limit = Integer.parseInt( a_limit ) ;
        }

        Hashtable l_env = new Hashtable() ;

        l_env.put( DerefAliasesEnum.JNDI_PROP, 
            DerefAliasesEnum.DEREFALWAYS_NAME ) ;

        NamingEnumeration l_cursor = m_backend.getEngine().search( 
            new LdapName( a_base ), l_env, l_root, null, l_ctls ) ;
        String [] l_cols = new String [2] ;
        l_cols[0] = "id" ;
        l_cols[1] = "dn" ;
        DefaultTableModel l_tableModel = new DefaultTableModel( l_cols, 0 ) ;
        Object [] l_row = new Object[2] ;
        int l_count = 0 ;
        while ( l_cursor.hasMore() && l_count < l_limit ) 
        {
            IndexRecord l_rec = ( IndexRecord ) l_cursor.next() ;
            l_row[0] = l_rec.getEntryId() ;
            l_row[1] = m_database.getEntryDn( ( BigInteger ) l_row[0] ) ;
            l_tableModel.addRow( l_row ) ;
            l_count++ ;
        }

        SearchResultDialog l_results = new SearchResultDialog( this, false ) ;
        StringBuffer l_buf = new StringBuffer() ;
        l_buf.append( "base: " ).append( a_base ).append( '\n' ) ;
        l_buf.append( "scope: " ).append( a_scope ).append( '\n' ) ;
        l_buf.append( "limit: " ).append( a_limit ).append( '\n' ) ;
        l_buf.append( "total: " ).append( l_count ).append( '\n' ) ;
        l_buf.append( "filter:\n" ).append( a_filter ).append( '\n' ) ;
        l_results.setFilter( l_buf.toString() ) ;

	    TreeNode l_astRoot = new ASTNode( null, l_root ) ;
	    TreeModel l_treeModel = new DefaultTreeModel( l_astRoot, true ) ;
        l_results.setTreeModel( l_treeModel ) ;
        l_results.setTableModel( l_tableModel ) ;
        centerOnScreen( l_results ) ;
        l_results.setVisible( true ) ;
        return true ;
    }


    public void doDebug( String a_filter, String a_scope, String a_base,
        String a_limit )
    {
        System.out.println( "Search attempt using filter '" + a_filter + "' "
            + "with scope '" + a_scope + "' and a return limit of '" + a_limit
            + "'" ) ;
    }


    public void selectTreeNode( BigInteger a_id )
    {
        Stack l_stack = new Stack() ;
        Object [] l_comps = null ;
        TreeNode l_parent = ( EntryNode ) m_nodes.get( a_id ) ;

        while ( l_parent != null && ( l_parent != l_parent.getParent() ) ) 
        {
            l_stack.push( l_parent ) ;
            l_parent = l_parent.getParent() ;
        }

        if ( l_stack.size() == 0 ) 
        {
            l_comps = new Object[1] ;
            l_comps[0] = m_root ;
        } 
        else 
        {
            l_comps = new Object[l_stack.size()] ;
        }

        for ( int ii = 0; l_stack.size() > 0 && ii < l_comps.length; ii++ ) 
        {
            l_comps[ii] = l_stack.pop() ;
        }

        TreePath l_path = new TreePath( l_comps ) ;
        m_tree.scrollPathToVisible( l_path ) ;
        m_tree.getSelectionModel().setSelectionPath( l_path ) ;
        m_tree.validate() ;
    }


    public boolean doAnnotate( String a_filter )
        throws Exception
    {
		FilterParser l_parser = new FilterParserImpl() ;
        l_parser.enableLogging( m_logger ) ;
        ExprNode l_root = null ;

        try 
        {
            l_root = l_parser.parse( a_filter ) ;
        } 
        catch( Exception e ) 
        {
            JTextArea l_text = new JTextArea() ;
            String l_msg = e.getMessage() ;

            if ( l_msg.length() > 1024 ) 
            {
                l_msg = l_msg.substring( 0, 1024 ) + "\n. . . truncated . . ." ;
            }

            l_text.setText( l_msg ) ;
            l_text.setEnabled( false ) ;
            JOptionPane.showMessageDialog( null, l_text, "Syntax Error",
                JOptionPane.ERROR_MESSAGE ) ;
            return false ;
        }

		AnnotatedFilterTreeDialog l_treeDialog = new
			AnnotatedFilterTreeDialog( BackendFrame.this, false ) ;
		l_treeDialog.setFilter( a_filter ) ;

        m_backend.getEngine().getOptimizer().annotate( l_root ) ;
		TreeNode l_astRoot = new ASTNode( null, l_root ) ;
		TreeModel l_model = new DefaultTreeModel( l_astRoot, true ) ;
		l_treeDialog.setModel( l_model ) ;
        l_treeDialog.setVisible( true ) ;
        return true ;
    }


    /**
     * Shows a dialog to display and scan indices.
     * 
     * @param a_idxAttr the name of the index or its attribute
     * @throws Exception if the indices cannot be accessed
     */
    public void showIndexDialog( String a_idxAttr )
        throws Exception
    {
        Index l_index = null ;
        boolean l_isSystem = m_database.hasSystemIndexOn( a_idxAttr ) ; 
        
        if ( l_isSystem )
        {
            l_index = ( Index ) m_database.getSystemIndex( a_idxAttr ) ;
        }
        else 
        {
            l_index = ( Index ) m_database.getUserIndex( a_idxAttr ) ;
        }

        if ( l_index != null ) 
        {
            IndexDialog l_dialog = new IndexDialog( this, false, l_index ) ;
            centerOnScreen( l_dialog ) ;
            l_dialog.setEnabled( true ) ;
            l_dialog.setVisible( true ) ;
        }
    }


    public void buildIndicesMenu( Database a_database )
    {
        JMenuItem l_item = null ;
        
        ActionListener l_listener = new ActionListener()
        {
            public void actionPerformed( ActionEvent a_event ) 
            {
                try 
                {
                    showIndexDialog( a_event.getActionCommand() ) ;
                } 
                catch ( Exception e ) 
                {
                    e.printStackTrace() ;
                }
            }
        } ;

        Iterator l_list = a_database.getSystemIndices() ;
        while ( l_list.hasNext() )
        {
            String l_idx = ( String ) l_list.next() ;
            l_item = new JMenuItem() ;
            l_item.setBackground( new java.awt.Color( 205, 205, 205 ) ) ;
            m_indices.add( l_item ) ;
            l_item.setText( l_idx ) ;
            l_item.setActionCommand( l_idx ) ;
            l_item.addActionListener( l_listener ) ;
        }

        m_indices.add( new JSeparator() ) ;
        l_list = a_database.getUserIndices() ;
        while ( l_list.hasNext() ) 
        {
            String l_idx = ( String ) l_list.next() ;
			l_item = new JMenuItem() ;
            l_item.setBackground( new java.awt.Color( 205, 205, 205 ) ) ;
            m_indices.add( l_item ) ;
            l_item.setText( l_idx ) ;
            l_item.setActionCommand( l_idx ) ;
            l_item.addActionListener( l_listener ) ;
        }
    }


    void displayEntry( BigInteger a_id, Attributes a_entry )
        throws Exception
    {
        String l_dn = m_database.getEntryUpdn( a_id ) ;
        AttributesTableModel l_model = 
            new AttributesTableModel( a_entry, a_id, l_dn, false ) ;
        m_entryTbl.setModel( l_model ) ;

        l_model = new AttributesTableModel( 
            m_database.getIndices( a_id ), a_id, l_dn, false ) ;
        m_idxTbl.setModel( l_model ) ;

        validate() ;
    }


    private void load() throws Exception
    {
        boolean doFiltered = false ;
        m_nodes = new HashMap() ;

        Attributes l_suffix = m_database.getSuffixEntry() ;
        BigInteger l_id = m_database.getEntryId( 
            m_database.getSuffix().toString() ) ;
        m_root = new EntryNode( l_id, null, m_database, l_suffix, m_nodes ) ;

        /*
        int l_option = JOptionPane.showConfirmDialog( null, 
            "Would you like to filter leaf nodes on load?", "Use Filter?",
            JOptionPane.OK_CANCEL_OPTION ) ;
        doFiltered = l_option == JOptionPane.OK_OPTION ;

        if(doFiltered) {
            SearchEngine l_engine = new SearchEngine() ;
            final FilterDialog l_dialog =
                new FilterDialog(FilterDialog.LOAD_MODE, this, true) ;
            l_dialog.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    l_dialog.setVisible(false) ;
                    l_dialog.dispose() ;
                }
            }) ;

            l_dialog.setBase(m_database.getSuffix().toString()) ;
            l_dialog.setScope(FilterDialog.SUBTREE_SCOPE) ;

            //Center the frame on screen
            l_dialog.setSize(456, 256) ;
            this.centerOnScreen( l_dialog ) ;
            l_dialog.setEnabled(true) ;
            l_dialog.setVisible(true) ;

            FilterParser l_parser = new FilterParserImpl() ;
            l_parser.enableLogging(m_logger) ;
            ExprNode l_exprNode = l_parser.parse(l_dialog.getFilter()) ;

            int l_scope = -1 ;
            String l_scopeStr = l_dialog.getScope() ;
            if(l_scopeStr == FilterDialog.BASE_SCOPE) {
                l_scope = Backend.BASE_SCOPE ;
            } else if(l_scopeStr == FilterDialog.SINGLE_SCOPE) {
                l_scope = Backend.SINGLE_SCOPE ;
            } else if(l_scopeStr == FilterDialog.SUBTREE_SCOPE) {
                l_scope = Backend.SUBTREE_SCOPE ;
            } else {
                throw new RuntimeException("Unrecognized scope") ;
            }

            l_exprNode =
                l_engine.addScopeNode(l_exprNode, l_dialog.getBase(), l_scope) ;
            m_root = new EntryNode(null, m_database,
                m_database.getSuffixEntry(), m_nodes, l_exprNode, l_engine) ;
        } else {
            m_root = new EntryNode(null, m_database,
                m_database.getSuffixEntry(), m_nodes) ;
        }
        */

        DefaultTreeModel l_model = new DefaultTreeModel( m_root ) ;
        m_tree.setModel( l_model ) ;

        if ( isVisible() ) 
        {
            m_tree.validate() ;
        }
    }
}
